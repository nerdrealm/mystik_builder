<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystik Creatures Deck Builder</title>
    <style>
        :root {
            --bg-color: #1e1e1e; /* Charcoal Black */
            --container-bg: #2d2d2d; /* Slightly Lighter Charcoal */
            --input-bg: #3c3c3c;
            --text-color: #FFD700; /* Golden Yellow */
            --text-light: #dcdcdc;
            --border-color: #FFD700; /* Golden Yellow */
            --btn-color: #FFD700; /* Golden Yellow */
            --btn-text-color: #1e1e1e; /* Dark text on yellow button */
            --btn-hover-color: #ffeb99; /* Lighter yellow for hover */
            
            /* Status Colors */
            --color-yellow-status: #f1c40f;
            --color-red-status: #e74c3c;
            --color-green-status: #2ecc71;
            --color-cyan-status: #1abc9c;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .main-container {
            width: 100%;
            max-width: 1200px;
            background-color: var(--container-bg);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.25);
        }

        header {
            display: flex; 
            align-items: center; 
            justify-content: center; 
            margin-bottom: 25px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 20px;
        }

        header img {
            max-width: 200px; 
            margin-right: 25px; 
        }

        header h1 {
            color: var(--text-color);
            margin: 0;
            font-size: 2.5em; 
            text-shadow: 0 0 5px var(--text-color);
        }

        #status {
            text-align: center;
            padding: 10px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
            color: var(--color-yellow-status);
            border: 1px solid;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background-color: var(--bg-color);
            border-radius: 8px;
        }
        
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            margin-bottom: 5px; 
            font-weight: bold;
            color: var(--text-color);
        }

        .theme-hint {
            font-size: 0.85em;
            color: #bbbbbb;
            margin-top: 0;
            margin-bottom: 10px;
            font-style: italic;
        }

        .control-group input[type="text"] {
            padding: 12px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-light);
            font-size: 1em;
        }
        
        .archetype-options {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .archetype-options label {
            cursor: pointer;
            padding: 10px 15px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            transition: all 0.2s ease-in-out;
        }
        
        .archetype-options input[type="radio"] {
            display: none;
        }
        
        .archetype-options input[type="radio"]:checked + label {
            background-color: var(--btn-color);
            color: var(--btn-text-color);
            font-weight: bold;
            box-shadow: 0 0 10px var(--btn-color);
        }

        .action-button {
            grid-column: 1 / -1;
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            color: var(--btn-text-color);
            background-color: var(--btn-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .action-button:hover {
            background-color: var(--btn-hover-color);
        }
        
        .action-button:disabled {
            background-color: #555;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
            border-color: #555;
        }

        #output {
            display: none; 
            padding-bottom: 20px;
        }
        
        #caution-message {
            text-align: center;
            padding: 15px;
            background-color: var(--bg-color);
            border: 2px solid var(--color-yellow-status);
            border-radius: 8px;
            margin-bottom: 20px;
        }

        #caution-message h3 {
            margin: 0 0 10px 0;
            font-weight: bold;
            text-transform: uppercase;
            color: var(--color-yellow-status);
        }

        #caution-message p {
            margin: 0;
            line-height: 1.5;
            color: var(--text-light);
        }
        
        #caution-message p:first-of-type {
            margin-bottom: 10px;
        }

        #deck-summary {
            text-align: center;
            padding: 15px;
            background-color: var(--bg-color);
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        #deck-summary h2 {
            margin: 0 0 10px 0;
            color: var(--text-color);
        }
        
        #deck-list-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .card-list {
            background-color: var(--bg-color);
            padding: 15px;
            border-radius: 8px;
        }
        
        .card-list h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--border-color);
            color: var(--text-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        
        .card-list ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        
        .card-list li {
            padding: 5px 0;
            border-bottom: 1px solid var(--input-bg);
        }

        .card-list li:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>

    <div class="main-container">
        <header>
            <img src="https://raw.githubusercontent.com/nerdrealm/mystik_builder/main/MystikLogo-PNG.png" 
                 alt="Mystik Creatures Logo" 
                 onerror="this.style.display='none'; this.nextSibling.style.display='block';">
            <p style="display:none; color: var(--color-red-status);">Logo failed to load. Make sure 'MystikLogo-PNG.png' exists in your public GitHub repository.</p>
            <h1>Mystik Creatures Deck Builder</h1>
        </header>

        <div id="status">Loading card data... Please wait.</div>

        <div class="controls">
            <div class="control-group">
                <label for="deckTheme">Deck Type Theme</label>
                <p class="theme-hint">Types: Fire, Water, Dark, Thunder, Earth, Wind, Forest, Light, or Blank. <br>Combine two with a slash (e.g., Fire/Dark).</p>
                <input type="text" id="deckTheme" placeholder="Enter a theme here...">
            </div>

            <div class="control-group">
                <label>Deck Archetype</label>
                <div id="archetype-options" class="archetype-options">
                    <!-- Options will be populated by JS -->
                </div>
            </div>

            <button id="generate-btn" class="action-button" disabled>Generate Deck</button>
        </div>

        <div id="caution-message" style="display: none;">
            <h3>CAUTION</h3>
            <p>Some cards in this deck may not fit your build or strategy, and others may not meet official deck-building rules.</p>
            <p>Always tailor your deck around your core Creatures, and be sure to follow all level, rarity, and card limits.</p>
        </div>

        <div id="output">
            <div id="deck-summary">
                <h2 id="deck-title"></h2>
                <p id="deck-stats"></p>
            </div>
            <div id="deck-list-container">
                <div class="card-list">
                    <h3 id="creatures-title">Creatures</h3>
                    <ul id="creatures-list"></ul>
                </div>
                <div class="card-list">
                    <h3 id="power-title">Power</h3>
                    <ul id="power-list"></ul>
                </div>
                <div class="card-list">
                    <h3 id="secrets-title">Secrets</h3>
                    <ul id="secrets-list"></ul>
                </div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

// --- CONFIGURATION & DECK RULES ---
const DECK_RULES = {
    "deck_size": 60,
    "creature_card_limits": { "Common": 4, "Uncommon": 3, "Rare": 2, "UltraRare": 2 },
    "level_10_limits": { "total": 4 },
    "power_card_limits": { "powerValue_1": Infinity, "powerValue_2": 5 },
    "secret_card_limits": { "Common": 3, "Uncommon": 2, "Rare": 1 }
};

const DECK_ARCHETYPES = {
    "Balanced": { "creatures": 0.40, "secrets": 0.35, "power": 0.25, "description": "A well-rounded deck" },
    "Aggro": { "creatures": 0.50, "secrets": 0.25, "power": 0.25, "description": "Creature-heavy and aggressive" },
    "Control": { "creatures": 0.30, "secrets": 0.45, "power": 0.25, "description": "Secret-heavy and disruptive" },
    "Energy": { "creatures": 0.35, "secrets": 0.30, "power": 0.35, "description": "Power-heavy for big plays" }
};

const ARCHETYPE_COLORS = {
    "Balanced": "var(--color-green-status)",
    "Aggro": "var(--color-red-status)",
    "Control": "var(--color-yellow-status)",
    "Energy": "var(--color-cyan-status)"
};

const TERRAIN_TYPE_COMPATIBILITY = {
    "Ancient Forests of Rehm": ["Forest"], "Aquatic Paradise": ["Water", "Forest"], "Dark Shadows": ["Dark"],
    "Huricanes off Jimbora": ["Thunder"], "Infernal Pits of Crom": ["Fire"], "Lights of Nura": ["Light"],
    "Mountains of Eurotha": ["Earth"], "Oceans of Nimbitu": ["Water"], "Pixie Forest": ["Forest"],
    "Poisonous Swamp": ["Earth", "Dark"], "Rough Seas": ["Water"], "Sacred Grounds": ["Thunder", "Light"],
    "Sandstorm": ["Earth"], "Scorched Fields": ["Wind", "Fire"], "Shadow Plains": ["Dark"],
    "Southern Winds of Us'ah": ["Wind"], "Star of Septeptus": ["Light"], "Stomy Skies": ["Thunder"],
    "Torn Wastelands": ["All"], "Volcanoes of Westu'ra": ["Fire"], "Winds off the Coast": ["Wind"]
};

// --- GLOBAL VARIABLES & DOM ELEMENTS ---
let all_cards = [];
let companion_map = {};
const statusDiv = document.getElementById('status');
const generateBtn = document.getElementById('generate-btn');
const themeInput = document.getElementById('deckTheme');
const archetypeOptionsDiv = document.getElementById('archetype-options');
const outputDiv = document.getElementById('output');
const deckTitleH2 = document.getElementById('deck-title');
const deckStatsP = document.getElementById('deck-stats');
const creaturesListUl = document.getElementById('creatures-list');
const powerListUl = document.getElementById('power-list');
const secretsListUl = document.getElementById('secrets-list');
const creaturesTitleH3 = document.getElementById('creatures-title');
const powerTitleH3 = document.getElementById('power-title');
const secretsTitleH3 = document.getElementById('secrets-title');
const cautionDiv = document.getElementById('caution-message');

const defaultdict = (defaultValueFactory) => new Proxy({}, {
    get: (target, name) => name in target ? target[name] : (target[name] = defaultValueFactory())
});

// --- DATA LOADING & INITIALIZATION ---
async function loadCardsFromJson(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        const unique_cards = [];
        const seen = new Set();
        for (const card of data) {
            card.script_uuid = crypto.randomUUID();
            const identifier = `${card.name}|${card.collectionNumber}`;
            if (!seen.has(identifier)) {
                unique_cards.push(card);
                seen.add(identifier);
            }
        }
        return unique_cards;
    } catch (e) {
        statusDiv.innerHTML = `<strong>ERROR:</strong> Failed to fetch card data.`;
        statusDiv.style.color = 'var(--color-red-status)';
        console.error("Error loading card data:", e);
        return null;
    }
}

// --- SYNERGY & HELPER FUNCTIONS ---
function getCompanionMap(cards) {
    const newCompanionMap = defaultdict(() => ({ creatures: [], secrets: [] }));
    for (const card of cards) {
        if (card.supertype !== 'Creature') continue;
        for (const ability of card.abilities || []) {
            for (const prereq of ability.prerequisites || []) {
                if (prereq.type === 'SacrificeSpecificCreature') newCompanionMap[card.name].creatures.push(prereq.creatureName);
                else if (prereq.type === 'PlaySpecificCard') newCompanionMap[card.name].secrets.push(prereq.cardName);
            }
        }
    }
    return newCompanionMap;
}

function analyzePowerRequirements(creatures) {
    const powerNeeds = defaultdict(() => 0);
    let totalPowerCost = 0;
    for (const creature of creatures) {
        for (const attack of creature.attacks || []) {
            for (const cost of attack.cost || []) {
                powerNeeds[cost.PowerType] += cost.count;
                totalPowerCost += cost.count;
            }
        }
    }
    const avgPowerPerCreature = creatures.length > 0 ? totalPowerCost / creatures.length : 2;
    const minPowerCards = Math.max(12, Math.floor(avgPowerPerCreature * creatures.length * 0.3));
    return [powerNeeds, minPowerCards];
}

const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

function scoreCreatureSynergyBlank(card) {
    let score = randInt(0, 20);
    if (Object.values(companion_map).some(v => v.creatures.includes(card.name))) score += 50;
    if (card.name in companion_map) score += 50;
    if (card.rarity === 'Rare') score += 20;
    if (card.rarity === 'UltraRare') score += 40;
    if ((card.level || 0) >= 7) score += 15;
    return score;
}

function scoreCreatureSynergy(card, deckTheme) {
    let score = randInt(0, 20);
    const cardTypes = card.types || [];
    const themeTypes = deckTheme.split('/');
    if (!themeTypes.some(t => cardTypes.includes(t))) return -1;
    score += 50;
    if (themeTypes.length > 1 && themeTypes.every(t => cardTypes.includes(t))) score += 40;
    const themeMechanics = { "Dark": ["Disruption", "Control"], "Fire": ["Damage", "StatBoost"], "Water": ["Healing", "Control", "CardManipulation"], "Earth": ["Defense", "StatBoost", "Healing"], "Wind": ["Control", "Utility", "CardManipulation"], "Thunder": ["Debuff", "Damage"], "Forest": ["Healing", "StatBoost", "Debuff"], "Light": ["Healing", "Utility", "CardManipulation", "Buff"] };
    const allEffects = [...(card.abilities || []).flatMap(a => a.structuredEffects || []), ...(card.attacks || []).flatMap(a => a.structuredEffects || [])];
    for (const effect of allEffects) {
        const category = effect.category;
        for (const theme of themeTypes) {
            if ((themeMechanics[theme] || []).includes(category)) score += 25;
        }
    }
    if (Object.values(companion_map).some(v => v.creatures.includes(card.name))) score += 30;
    if (card.name in companion_map) score += 30;
    if (card.rarity === 'Rare') score += 15;
    if (card.rarity === 'UltraRare') score += 25;
    if ((card.level || 0) >= 7) score += 10;
    return score;
}

function scoreSecretSynergy(card, deckTheme, creaturesInDeck) {
    const cardName = card.name || '';
    const themeTypes = deckTheme.split('/');
    if (deckTheme === 'Blank' && (card.subtypes || [null])[0] === 'Terrain') return -1;
    for (const bossName in companion_map) {
        if (companion_map[bossName].secrets.includes(cardName)) {
            const isBossPresent = creaturesInDeck.some(c => c.name === bossName);
            return isBossPresent ? 1000 : -1;
        }
    }
    let score = randInt(0, 10);
    if ((card.subtypes || [null])[0] === 'Terrain') {
        const validTypes = TERRAIN_TYPE_COMPATIBILITY[cardName] || [];
        let terrainMatchesTheme = false;
        if (validTypes.includes("All") && deckTheme !== 'Blank') {
            terrainMatchesTheme = true;
            score += 60;
        } else {
            for (const themeType of themeTypes) {
                if (validTypes.includes(themeType)) {
                    terrainMatchesTheme = true;
                    score += 80;
                    break;
                }
            }
        }
        if (!terrainMatchesTheme) return -1;
    } else {
        const effectText = (card.effectText || '').toLowerCase();
        for (const theme of themeTypes) {
            if (effectText.includes(theme.toLowerCase())) score += 25;
        }
    }
    return score;
}

// --- CORE DECK BUILDING FUNCTION ---
function buildStrategicDeck(selectedTypes, archetype_name) {
    const deck = { "Creatures": [], "Power": [], "Secrets": [] };
    const archetype = DECK_ARCHETYPES[archetype_name];
    const is_blank_deck = (selectedTypes === 'Blank');

    let targetCreatures = Math.floor(DECK_RULES.deck_size * archetype.creatures);
    let targetSecrets = Math.floor(DECK_RULES.deck_size * archetype.secrets);
    let targetPower = Math.floor(DECK_RULES.deck_size * archetype.power);

    // --- 2. CREATURE SELECTION ---
    const creatureSelectionFn = is_blank_deck ? scoreCreatureSynergyBlank : (c) => scoreCreatureSynergy(c, selectedTypes);
    const available_creatures = all_cards.filter(c => c.supertype === 'Creature' && (is_blank_deck || (c.types || []).some(t => selectedTypes.split('/').includes(t))));
    const scored_creatures = available_creatures.map(c => [c, creatureSelectionFn(c)]).sort((a, b) => b[1] - a[1]);
    
    let scored_low = scored_creatures.filter(([c, s]) => (c.level || 0) >= 1 && (c.level || 0) <= 3);
    let scored_mid = scored_creatures.filter(([c, s]) => (c.level || 0) >= 4 && (c.level || 0) <= 6);
    let scored_high = scored_creatures.filter(([c, s]) => (c.level || 0) >= 7);
    const creatureCounts = defaultdict(() => 0);
    let level_10_count = 0;

    while (deck.Creatures.length < targetCreatures) {
        const num_low = deck.Creatures.filter(c => (c.level || 0) >= 1 && (c.level || 0) <= 3).length;
        const num_mid = deck.Creatures.filter(c => (c.level || 0) >= 4 && (c.level || 0) <= 6).length;
        let selectionPool = [];
        if (num_low < Math.floor(targetCreatures * 0.45) && scored_low.length > 0) selectionPool.push(...scored_low.slice(0, 10));
        if (num_mid < Math.floor(targetCreatures * 0.35) && scored_mid.length > 0) selectionPool.push(...scored_mid.slice(0, 7));
        if (scored_high.length > 0) selectionPool.push(...scored_high.slice(0, 5));
        if (selectionPool.length === 0) {
            selectionPool.push(...scored_low.slice(0, 10), ...scored_mid.slice(0, 7), ...scored_high.slice(0, 5));
            if (selectionPool.length === 0) break;
        }
        const uniquePool = [...new Map(selectionPool.map(item => [item[0].script_uuid, item])).values()];
        if (uniquePool.length === 0) break;
        const [card_to_add, _] = uniquePool[Math.floor(Math.random() * uniquePool.length)];
        const { name: card_name, rarity: card_rarity, level: card_level = 0 } = card_to_add;
        if ((card_level === 10 && level_10_count >= DECK_RULES.level_10_limits.total) || (creatureCounts[card_name] >= (DECK_RULES.creature_card_limits[card_rarity] || 1))) {
            scored_low = scored_low.filter(([c,s]) => c.script_uuid !== card_to_add.script_uuid);
            scored_mid = scored_mid.filter(([c,s]) => c.script_uuid !== card_to_add.script_uuid);
            scored_high = scored_high.filter(([c,s]) => c.script_uuid !== card_to_add.script_uuid);
            continue;
        }
        deck.Creatures.push(card_to_add);
        creatureCounts[card_name]++;
        if (card_level === 10) level_10_count++;
        if (card_name in companion_map) {
            for (const comp_name of companion_map[card_name].creatures) {
                const comp_card = available_creatures.find(c => c.name === comp_name);
                if (comp_card && creatureCounts[comp_name] < (DECK_RULES.creature_card_limits[comp_card.rarity] || 2) && deck.Creatures.length < targetCreatures) {
                    deck.Creatures.push(comp_card);
                    creatureCounts[comp_name]++;
                }
            }
        }
    }

    // --- 3. POWER CARD SELECTION & ADJUSTMENT ---
    const [power_needs, min_power_needed] = analyzePowerRequirements(deck.Creatures);
    if (targetPower < min_power_needed) {
        const power_deficit = min_power_needed - targetPower;
        targetPower = min_power_needed;
        const creature_ratio = archetype.creatures / (archetype.creatures + archetype.secrets) || 0.5;
        targetCreatures = Math.max(15, targetCreatures - Math.round(power_deficit * creature_ratio));
        targetSecrets = Math.max(8, targetSecrets - (power_deficit - Math.round(power_deficit * creature_ratio)));
        while (deck.Creatures.length > targetCreatures) deck.Creatures.pop();
    }
    
    // ... (Power selection logic remains the same)

    // =========================================================================
    // START OF REVISED, NUANCED SECRET CARD SELECTION LOGIC
    // =========================================================================
    const available_secrets = all_cards.filter(c => c.supertype === 'Secret');
    let scored_secrets = [];
    for (const secret of available_secrets) {
        const synergy_score = scoreSecretSynergy(secret, selectedTypes, deck.Creatures);
        if (synergy_score >= 0) {
            scored_secrets.push([secret, synergy_score]);
        }
    }
    scored_secrets.sort((a, b) => b[1] - a[1]);

    const companionSecrets = scored_secrets.filter(([card, score]) => score >= 1000);
    const terrainSecrets = scored_secrets.filter(([card, score]) => (card.subtypes || [null])[0] === 'Terrain' && score < 1000);
    const generalSecrets = scored_secrets.filter(([card, score]) => (card.subtypes || [null])[0] !== 'Terrain' && score < 1000);

    const secret_counts = defaultdict(() => 0);
    const terrain_counts = defaultdict(() => 0);

    while (deck.Secrets.length < targetSecrets) {
        const currentTerrainCount = Object.keys(terrain_counts).length > 0 ? deck.Secrets.filter(c => (c.subtypes || [null])[0] === 'Terrain').length : 0;
        
        let selectionPool = [];
        selectionPool.push(...companionSecrets);
        if (currentTerrainCount < 3) {
            selectionPool.push(...terrainSecrets.slice(0, 5));
        }
        selectionPool.push(...generalSecrets.slice(0, 10));

        let validCandidates = [];
        for (const [card, score] of selectionPool) {
            const card_name = card.name;
            const card_rarity = card.rarity;
            const is_terrain = (card.subtypes || [null])[0] === 'Terrain';

            if (secret_counts[card_name] >= (DECK_RULES.secret_card_limits[card_rarity] || 1)) {
                continue;
            }
            if (is_terrain && (currentTerrainCount >= 4 || (!(card_name in terrain_counts) && Object.keys(terrain_counts).length >= 3))) {
                continue;
            }
            validCandidates.push([card, score]);
        }

        if (validCandidates.length === 0) {
            break; 
        }

        const [card_to_add, _] = validCandidates[Math.floor(Math.random() * validCandidates.length)];

        deck.Secrets.push(card_to_add);
        secret_counts[card_to_add.name]++;
        if ((card_to_add.subtypes || [null])[0] === 'Terrain') {
            terrain_counts[card_to_add.name]++;
        }
    }
    // =========================================================================
    // END OF REVISED SECRET CARD LOGIC
    // =========================================================================

    // --- 5. FINAL ADJUSTMENT ---
    while (deck.Creatures.length + deck.Power.length + deck.Secrets.length > 60) {
        if (deck.Power.length > targetPower) deck.Power.pop();
        else if (deck.Secrets.length > targetSecrets) deck.Secrets.pop();
        else deck.Creatures.pop();
    }
    const powerCardsByType = defaultdict(() => []);
    all_cards.filter(c => c.supertype === 'Power').forEach(c => powerCardsByType[c.powerType].push(c));
    while (deck.Creatures.length + deck.Power.length + deck.Secrets.length < 60) {
        let power_card_to_add = (powerCardsByType['Blank'] || [null])[0];
        if (!is_blank_deck) {
            const main_theme = selectedTypes.split('/')[0];
            const themed_power_card = (powerCardsByType[main_theme] || []).find(c => (c.powerValue || 1) === 1);
            power_card_to_add = themed_power_card || power_card_to_add;
        }
        if (power_card_to_add) deck.Power.push(power_card_to_add);
        else break;
    }
        
    return deck;
}


// --- DECK DISPLAY & EVENT LISTENERS ---
function displayDeck(deck, deckTheme, archetype) {
    outputDiv.style.display = 'block';
    const color = ARCHETYPE_COLORS[archetype] || 'var(--text-color)';
    deckTitleH2.textContent = `${deckTheme} ${archetype} Deck`;
    [deckTitleH2, creaturesTitleH3, powerTitleH3, secretsTitleH3].forEach(el => el.style.color = color);
    const total = deck.Creatures.length + deck.Power.length + deck.Secrets.length;
    deckStatsP.textContent = `Total Cards: ${total} | Creatures: ${deck.Creatures.length}, Power: ${deck.Power.length}, Secrets: ${deck.Secrets.length}`;
    const populateList = (listElement, cards, displayFormatter) => {
        listElement.innerHTML = '';
        if (cards.length === 0) { listElement.innerHTML = '<li>None</li>'; return; }
        const counts = new Map();
        cards.forEach(card => {
            const key = displayFormatter(card);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        [...counts.keys()].forEach(key => {
            const li = document.createElement('li');
            li.textContent = `${key} x${counts.get(key)}`;
            listElement.appendChild(li);
        });
    };
    deck.Creatures.sort((a, b) => (a.level || 0) - (b.level || 0) || a.name.localeCompare(b.name));
    populateList(creaturesListUl, deck.Creatures, c => `${c.name} (Lvl ${c.level || '?'}, ${(c.types || ['?'])[0]}, ${c.rarity})`);
    populateList(powerListUl, deck.Power, p => `${p.powerType} Power ${(p.powerValue || 1) === 2 ? '(x2)' : ''} (${p.rarity})`);
    populateList(secretsListUl, deck.Secrets, s => `${s.name} (${(s.subtypes || ['?'])[0]}, ${s.rarity})`);
}

async function initialize() {
    Object.entries(DECK_ARCHETYPES).forEach(([name, data], index) => {
        const input = document.createElement('input');
        input.type = 'radio'; input.id = `archetype-${name}`; input.name = 'archetype'; input.value = name;
        if (index === 0) input.checked = true;
        const label = document.createElement('label');
        label.htmlFor = `archetype-${name}`; label.textContent = name; label.title = data.description;
        archetypeOptionsDiv.appendChild(input);
        archetypeOptionsDiv.appendChild(label);
    });
    const cardDataUrl = 'https://raw.githubusercontent.com/nerdrealm/mystik_builder/main/cardProfiles.json';
    all_cards = await loadCardsFromJson(cardDataUrl);
    if (all_cards) {
        companion_map = getCompanionMap(all_cards);
        statusDiv.textContent = `Ready to build. Please select a theme and archetype.`;
        statusDiv.style.color = 'var(--color-green-status)';
        generateBtn.disabled = false;
    } else {
        generateBtn.disabled = true;
    }
    generateBtn.addEventListener('click', () => {
        const rawThemeInput = themeInput.value.trim();
        if (!rawThemeInput) { alert("Please enter a Deck Type Theme."); return; }
        const normalizedParts = rawThemeInput.split('/').map(p => p.trim()).map(p => p.charAt(0).toUpperCase() + p.slice(1).toLowerCase());
        const deckTheme = normalizedParts.join('/');
        const archetype = document.querySelector('input[name="archetype"]:checked').value;
        statusDiv.textContent = `Building a(n) ${archetype} deck with the ${deckTheme} theme...`;
        statusDiv.style.color = 'var(--color-cyan-status)';
        cautionDiv.style.display = 'none';
        setTimeout(() => {
            try {
                const deck = buildStrategicDeck(deckTheme, archetype);
                displayDeck(deck, deckTheme, archetype);
                statusDiv.textContent = "Deck generated successfully!";
                statusDiv.style.color = 'var(--color-green-status)';
                cautionDiv.style.display = 'block';
            } catch (e) {
                statusDiv.textContent = "An error occurred during deck generation. See console for details.";
                statusDiv.style.color = 'var(--color-red-status)';
                console.error(e);
            }
        }, 50);
    });
}

initialize();

});
</script>

</body>
</html>
