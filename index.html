<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystik Creatures Deck Builder</title>
    <style>
        :root {
            --bg-color: #1e1e1e; /* Charcoal Black */
            --container-bg: #2d2d2d; /* Slightly Lighter Charcoal */
            --input-bg: #3c3c3c;
            --text-color: #FFD700; /* Golden Yellow */
            --text-light: #dcdcdc;
            --border-color: #FFD700; /* Golden Yellow */
            --btn-color: #FFD700; /* Golden Yellow */
            --btn-text-color: #1e1e1e; /* Dark text on yellow button */
            --btn-hover-color: #ffeb99; /* Lighter yellow for hover */
            
            /* Status Colors */
            --color-yellow-status: #f1c40f;
            --color-red-status: #e74c3c;
            --color-green-status: #2ecc71;
            --color-cyan-status: #1abc9c;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .main-container {
            width: 100%;
            max-width: 1200px;
            background-color: var(--container-bg);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.25);
        }

        header {
            display: flex; 
            align-items: center; 
            justify-content: center; 
            margin-bottom: 25px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 20px;
        }

        header img {
            max-width: 200px; 
            margin-right: 25px; 
        }

        header h1 {
            color: var(--text-color);
            margin: 0;
            font-size: 2.5em; 
            text-shadow: 0 0 5px var(--text-color);
        }

        #status {
            text-align: center;
            padding: 10px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
            color: var(--color-yellow-status);
            border: 1px solid;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background-color: var(--bg-color);
            border-radius: 8px;
        }
        
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            margin-bottom: 5px; 
            font-weight: bold;
            color: var(--text-color);
        }

        .theme-hint {
            font-size: 0.85em;
            color: #bbbbbb;
            margin-top: 0;
            margin-bottom: 10px;
            font-style: italic;
        }

        .control-group input[type="text"] {
            padding: 12px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-light);
            font-size: 1em;
        }
        
        .archetype-options {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .archetype-options label {
            cursor: pointer;
            padding: 10px 15px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            transition: all 0.2s ease-in-out;
        }
        
        .archetype-options input[type="radio"] {
            display: none;
        }
        
        .archetype-options input[type="radio"]:checked + label {
            background-color: var(--btn-color);
            color: var(--btn-text-color);
            font-weight: bold;
            box-shadow: 0 0 10px var(--btn-color);
        }

        .action-button {
            grid-column: 1 / -1;
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            color: var(--btn-text-color);
            background-color: var(--btn-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .action-button:hover {
            background-color: var(--btn-hover-color);
        }
        
        .action-button:disabled {
            background-color: #555;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
            border-color: #555;
        }

        #output {
            display: none; 
            padding-bottom: 20px;
        }
        
        #deck-summary {
            text-align: center;
            padding: 15px;
            background-color: var(--bg-color);
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        #deck-summary h2 {
            margin: 0 0 10px 0;
            color: var(--text-color);
        }
        
        #deck-list-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .card-list {
            background-color: var(--bg-color);
            padding: 15px;
            border-radius: 8px;
        }
        
        .card-list h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--border-color);
            color: var(--text-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        
        .card-list ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        
        .card-list li {
            padding: 5px 0;
            border-bottom: 1px solid var(--input-bg);
        }

        .card-list li:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>

    <div class="main-container">
        <header>
            <img src="https://raw.githubusercontent.com/nerdrealm/mystik_builder/main/MystikLogo-PNG.png" 
                 alt="Mystik Creatures Logo" 
                 onerror="this.style.display='none'; this.nextSibling.style.display='block';">
            <p style="display:none; color: var(--color-red-status);">Logo failed to load. Make sure 'MystikLogo-PNG.png' exists in your public GitHub repository.</p>
            <h1>Mystik Creatures Deck Builder</h1>
        </header>

        <div id="status">Loading card data... Please wait.</div>

        <div class="controls">
            <div class="control-group">
                <label for="deckTheme">Deck Type Theme</label>
                <p class="theme-hint">Types: Fire, Water, Dark, Thunder, Earth, Wind, Forest, Light, or Blank. <br>Combine two with a slash (e.g., Fire/Dark).</p>
                <input type="text" id="deckTheme" placeholder="Enter a theme here...">
            </div>

            <div class="control-group">
                <label>Deck Archetype</label>
                <div id="archetype-options" class="archetype-options">
                    <!-- Options will be populated by JS -->
                </div>
            </div>

            <button id="generate-btn" class="action-button" disabled>Generate Deck</button>
        </div>

        <div id="output">
            <div id="deck-summary">
                <h2 id="deck-title"></h2>
                <p id="deck-stats"></p>
            </div>
            <div id="deck-list-container">
                <div class="card-list">
                    <h3 id="creatures-title">Creatures</h3>
                    <ul id="creatures-list"></ul>
                </div>
                <div class="card-list">
                    <h3 id="power-title">Power</h3>
                    <ul id="power-list"></ul>
                </div>
                <div class="card-list">
                    <h3 id="secrets-title">Secrets</h3>
                    <ul id="secrets-list"></ul>
                </div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

// --- CONFIGURATION & DECK RULES (FROM PYTHON SCRIPT) ---
const DECK_RULES = {
    "deck_size": 60,
    "creature_card_limits": { "Common": 4, "Uncommon": 3, "Rare": 2, "UltraRare": 2 },
    "level_10_limits": { "total": 4 },
    "power_card_limits": { "powerValue_1": Infinity, "powerValue_2": 5 },
    "secret_card_limits": { "Common": 3, "Uncommon": 2, "Rare": 1 }
};

const DECK_ARCHETYPES = {
    "Balanced": { "creatures": 0.40, "secrets": 0.35, "power": 0.25, "description": "A well-rounded deck with good balance of creatures, secrets, and power" },
    "Aggro": { "creatures": 0.50, "secrets": 0.25, "power": 0.25, "description": "Creature-heavy deck focused on fast, aggressive gameplay" },
    "Control": { "creatures": 0.30, "secrets": 0.45, "power": 0.25, "description": "Secret-heavy deck focused on controlling the game and disruption" },
    "Energy": { "creatures": 0.35, "secrets": 0.30, "power": 0.35, "description": "Power-heavy deck with strong energy management and big plays" }
};

const TERRAIN_TYPE_COMPATIBILITY = {
    "Ancient Forests of Rehm": ["Forest"], "Aquatic Paradise": ["Water", "Forest"], "Dark Shadows": ["Dark"],
    "Huricanes off Jimbora": ["Thunder"], "Infernal Pits of Crom": ["Fire"], "Lights of Nura": ["Light"],
    "Mountains of Eurotha": ["Earth"], "Oceans of Nimbitu": ["Water"], "Pixie Forest": ["Forest"],
    "Poisonous Swamp": ["Earth", "Dark"], "Rough Seas": ["Water"], "Sacred Grounds": ["Thunder", "Light"],
    "Sandstorm": ["Earth"], "Scorched Fields": ["Wind", "Fire"], "Shadow Plains": ["Dark"],
    "Southern Winds of Us'ah": ["Wind"], "Star of Septeptus": ["Light"], "Stomy Skies": ["Thunder"],
    "Torn Wastelands": ["All"], "Volcanoes of Westu'ra": ["Fire"], "Winds off the Coast": ["Wind"]
};

// --- GLOBAL VARIABLES ---
let all_cards = [];
let companion_map = {};

// --- DOM ELEMENTS ---
const statusDiv = document.getElementById('status');
const generateBtn = document.getElementById('generate-btn');
const themeInput = document.getElementById('deckTheme');
const archetypeOptionsDiv = document.getElementById('archetype-options');
const outputDiv = document.getElementById('output');
const deckTitleH2 = document.getElementById('deck-title');
const deckStatsP = document.getElementById('deck-stats');
const creaturesListUl = document.getElementById('creatures-list');
const powerListUl = document.getElementById('power-list');
const secretsListUl = document.getElementById('secrets-list');
const creaturesTitleH3 = document.getElementById('creatures-title');
const powerTitleH3 = document.getElementById('power-title');
const secretsTitleH3 = document.getElementById('secrets-title');

// --- HELPER FUNCTIONS ---
const defaultdict = (defaultValueFactory) => new Proxy({}, {
    get: (target, name) => name in target ? target[name] : (target[name] = defaultValueFactory())
});

// --- DATA LOADING ---
async function loadCardsFromJson(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        
        const unique_cards = [];
        const seen = new Set();
        for (const card of data) {
            card.script_uuid = crypto.randomUUID();
            const identifier = `${card.name}|${card.collectionNumber}`;
            if (!seen.has(identifier)) {
                unique_cards.push(card);
                seen.add(identifier);
            }
        }
        return unique_cards;
    } catch (e) {
        statusDiv.innerHTML = `<strong>ERROR:</strong> Failed to fetch card data from GitHub.<br>Please make sure a file named 'cardProfiles.json' exists in your public repository.`;
        statusDiv.style.color = 'var(--color-red-status)';
        console.error("Error loading card data:", e);
        return null;
    }
}

// --- SYNERGY AND HELPER FUNCTIONS (TRANSLATED FROM PYTHON) ---
function getCompanionMap(cards) {
    const newCompanionMap = defaultdict(() => ({ creatures: [], secrets: [] }));
    for (const card of cards) {
        if (card.supertype !== 'Creature') continue;
        for (const ability of card.abilities || []) {
            for (const prereq of ability.prerequisites || []) {
                if (prereq.type === 'SacrificeSpecificCreature') {
                    newCompanionMap[card.name].creatures.push(prereq.creatureName);
                } else if (prereq.type === 'PlaySpecificCard') {
                    newCompanionMap[card.name].secrets.push(prereq.cardName);
                }
            }
        }
    }
    return newCompanionMap;
}

function analyzePowerRequirements(creatures) {
    const powerNeeds = defaultdict(() => 0);
    let totalPowerCost = 0;

    for (const creature of creatures) {
        for (const attack of creature.attacks || []) {
            for (const cost of attack.cost || []) {
                powerNeeds[cost.PowerType] += cost.count;
                totalPowerCost += cost.count;
            }
        }
    }
    const avgPowerPerCreature = creatures.length > 0 ? totalPowerCost / creatures.length : 2;
    const minPowerCards = Math.max(12, Math.floor(avgPowerPerCreature * creatures.length * 0.3));
    return [powerNeeds, minPowerCards];
}

const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

function scoreCreatureSynergyBlank(card) {
    let score = randInt(0, 20);
    if (Object.values(companion_map).some(v => v.creatures.includes(card.name))) score += 50;
    if (card.name in companion_map) score += 50;
    if (card.rarity === 'Rare') score += 20;
    if (card.rarity === 'UltraRare') score += 40;
    if ((card.level || 0) >= 7) score += 15;
    return score;
}

function scoreCreatureSynergy(card, deckTheme, existingCreatures) {
    let score = randInt(0, 20);
    const cardTypes = card.types || [];
    const themeTypes = deckTheme.split('/');
    if (!themeTypes.some(t => cardTypes.includes(t))) return -1;
    score += 50;
    if (themeTypes.length > 1 && themeTypes.every(t => cardTypes.includes(t))) score += 40;

    const themeMechanics = {
        "Dark": ["Disruption", "Control"], "Fire": ["Damage", "StatBoost"], "Water": ["Healing", "Control", "CardManipulation"],
        "Earth": ["Defense", "StatBoost", "Healing"], "Wind": ["Control", "Utility", "CardManipulation"], "Thunder": ["Debuff", "Damage"],
        "Forest": ["Healing", "StatBoost", "Debuff"], "Light": ["Healing", "Utility", "CardManipulation", "Buff"]
    };

    const allEffects = [];
    (card.abilities || []).forEach(ability => allEffects.push(...(ability.structuredEffects || [])));
    (card.attacks || []).forEach(attack => allEffects.push(...(attack.structuredEffects || [])));

    for (const effect of allEffects) {
        const category = effect.category;
        for (const theme of themeTypes) {
            if ((themeMechanics[theme] || []).includes(category)) {
                score += 25;
            }
        }
    }
    if (Object.values(companion_map).some(v => v.creatures.includes(card.name))) score += 30;
    if (card.name in companion_map) score += 30;
    if (card.rarity === 'Rare') score += 15;
    if (card.rarity === 'UltraRare') score += 25;
    if ((card.level || 0) >= 7) score += 10;
    return score;
}

function scoreSecretSynergy(card, deckTheme, creaturesInDeck) {
    const cardName = card.name || '';
    const themeTypes = deckTheme.split('/');

    if (deckTheme === 'Blank' && (card.subtypes || [null])[0] === 'Terrain') {
        return -1;
    }

    for (const bossName in companion_map) {
        if (companion_map[bossName].secrets.includes(cardName)) {
            const isBossPresent = creaturesInDeck.some(c => c.name === bossName);
            return isBossPresent ? 1000 : -1;
        }
    }

    let score = randInt(0, 10);
    if ((card.subtypes || [null])[0] === 'Terrain') {
        const validTypes = TERRAIN_TYPE_COMPATIBILITY[cardName] || [];
        let terrainMatchesTheme = false;
        
        if (validTypes.includes("All") && deckTheme !== 'Blank') {
            terrainMatchesTheme = true;
            score += 60;
        } else {
            for (const themeType of themeTypes) {
                if (validTypes.includes(themeType)) {
                    terrainMatchesTheme = true;
                    score += 80;
                    break;
                }
            }
        }
        if (!terrainMatchesTheme) return -1;
    } else {
        const effectText = (card.effectText || '').toLowerCase();
        for (const theme of themeTypes) {
            if (effectText.includes(theme.toLowerCase())) {
                score += 25;
            }
        }
    }
    return score;
}


function buildStrategicDeck(selectedTypes, archetype_name) {
    const deck = { "Creatures": [], "Power": [], "Secrets": [] };
    const archetype = DECK_ARCHETYPES[archetype_name];
    const is_blank_deck = (selectedTypes === 'Blank');

    let targetCreatures = Math.floor(DECK_RULES.deck_size * archetype.creatures);
    let targetSecrets = Math.floor(DECK_RULES.deck_size * archetype.secrets);
    let targetPower = Math.floor(DECK_RULES.deck_size * archetype.power);

    // --- 2. STRATIFIED CREATURE SELECTION ---
    let available_creatures, scored_creatures;
    if (is_blank_deck) {
        available_creatures = all_cards.filter(c => c.supertype === 'Creature');
        scored_creatures = available_creatures.map(c => [c, scoreCreatureSynergyBlank(c)]).sort((a, b) => b[1] - a[1]);
    } else {
        const themeTypes = selectedTypes.split('/');
        available_creatures = all_cards.filter(c => c.supertype === 'Creature' && (c.types || []).some(t => themeTypes.includes(t)));
        scored_creatures = available_creatures.map(c => [c, scoreCreatureSynergy(c, selectedTypes, [])]).sort((a, b) => b[1] - a[1]);
    }
    
    const LOW_LVL_TIER_PCT = 0.45, MID_LVL_TIER_PCT = 0.35;
    const target_low_lvl = Math.floor(targetCreatures * LOW_LVL_TIER_PCT);
    const target_mid_lvl = Math.floor(targetCreatures * MID_LVL_TIER_PCT);
    
    let scored_low = scored_creatures.filter(([c, s]) => (c.level || 0) >= 1 && (c.level || 0) <= 3);
    let scored_mid = scored_creatures.filter(([c, s]) => (c.level || 0) >= 4 && (c.level || 0) <= 6);
    // --- BUG FIX FOR LEVEL 10 CARDS ---
    // This now correctly includes level 7, 8, 9, AND 10 cards in the high-level pool.
    let scored_high = scored_creatures.filter(([c, s]) => (c.level || 0) >= 7);

    const creatureCounts = defaultdict(() => 0);
    let level_10_count = 0;

    while (deck.Creatures.length < targetCreatures) {
        const num_low = deck.Creatures.filter(c => (c.level || 0) >= 1 && (c.level || 0) <= 3).length;
        const num_mid = deck.Creatures.filter(c => (c.level || 0) >= 4 && (c.level || 0) <= 6).length;
        
        let source_list = [];
        if (num_low < target_low_lvl && scored_low.length > 0) source_list = scored_low;
        else if (num_mid < target_mid_lvl && scored_mid.length > 0) source_list = scored_mid;
        else if (scored_high.length > 0) source_list = scored_high;
        else source_list = scored_low.length > 0 ? scored_low : (scored_mid.length > 0 ? scored_mid : scored_high);
        
        if (source_list.length === 0) break;

        const pool = source_list.slice(0, 15);
        const [card_to_add, _] = pool[Math.floor(Math.random() * pool.length)];

        if (!card_to_add) {
            const uuidToRemove = source_list[0][0].script_uuid;
            scored_low = scored_low.filter(([c,s]) => c.script_uuid !== uuidToRemove);
            scored_mid = scored_mid.filter(([c,s]) => c.script_uuid !== uuidToRemove);
            scored_high = scored_high.filter(([c,s]) => c.script_uuid !== uuidToRemove);
            continue;
        }

        const { name: card_name, rarity: card_rarity, level: card_level = 0 } = card_to_add;
        
        if ((card_level === 10 && level_10_count >= DECK_RULES.level_10_limits.total) ||
            (creatureCounts[card_name] >= (DECK_RULES.creature_card_limits[card_rarity] || 1))) {
            const uuidToRemove = card_to_add.script_uuid;
            scored_low = scored_low.filter(([c,s]) => c.script_uuid !== uuidToRemove);
            scored_mid = scored_mid.filter(([c,s]) => c.script_uuid !== uuidToRemove);
            scored_high = scored_high.filter(([c,s]) => c.script_uuid !== uuidToRemove);
            continue;
        }

        deck.Creatures.push(card_to_add);
        creatureCounts[card_name]++;
        if (card_level === 10) level_10_count++;
        
        if (card_name in companion_map) {
            for (const comp_name of companion_map[card_name].creatures) {
                const comp_card = available_creatures.find(c => c.name === comp_name);
                if (comp_card && creatureCounts[comp_name] < (DECK_RULES.creature_card_limits[comp_card.rarity] || 2) && deck.Creatures.length < targetCreatures) {
                    deck.Creatures.push(comp_card);
                    creatureCounts[comp_name]++;
                }
            }
        }
    }

    const [power_needs, min_power_needed] = analyzePowerRequirements(deck.Creatures);
    if (targetPower < min_power_needed) {
        const power_deficit = min_power_needed - targetPower;
        targetPower = min_power_needed;
        const creature_ratio = archetype.creatures / (archetype.creatures + archetype.secrets) || 0.5;
        targetCreatures = Math.max(15, targetCreatures - Math.round(power_deficit * creature_ratio));
        targetSecrets = Math.max(8, targetSecrets - (power_deficit - Math.round(power_deficit * creature_ratio)));
        while (deck.Creatures.length > targetCreatures) deck.Creatures.pop();
    }

    // --- 3. POWER CARD SELECTION ---
    const powerCardsByType = defaultdict(() => []);
    all_cards.filter(c => c.supertype === 'Power').forEach(c => powerCardsByType[c.powerType].push(c));
    
    const powerDistribution = defaultdict(() => 0);
    if (is_blank_deck) {
        const creature_type_counts = defaultdict(() => 0);
        deck.Creatures.forEach(c => (c.types || []).forEach(type => creature_type_counts[type]++));
        
        const min_blank_power = Math.max(Math.floor(targetPower / 2), 3);
        for (const type in creature_type_counts) {
            powerDistribution[type] = Math.max(1, Math.min(creature_type_counts[type], 2));
        }
        
        const used_power = Object.values(powerDistribution).reduce((a, b) => a + b, 0);
        const remaining_slots = targetPower - used_power;
        const blank_allocation = Math.max(min_blank_power, remaining_slots);
        powerDistribution['Blank'] = Math.min(blank_allocation, 12);

        let total_allocated = Object.values(powerDistribution).reduce((a, b) => a + b, 0);
        if (total_allocated > targetPower) {
            const excess = total_allocated - targetPower;
            powerDistribution['Blank'] = Math.max(min_blank_power, powerDistribution['Blank'] - excess);
        }
    } else {
        Object.assign(powerDistribution, power_needs);
        const themeTypes = selectedTypes.split('/');
        themeTypes.forEach(themeType => {
            if (!(themeType in powerDistribution)) powerDistribution[themeType] = 0;
            const min_for_theme = Math.max(2, Math.floor(targetPower / (themeTypes.length * 3)));
            powerDistribution[themeType] = Math.max(powerDistribution[themeType], min_for_theme);
        });
    }

    let double_power_count = 0;
    const power_efficiency_threshold = 2.5;

    while (deck.Power.length < targetPower) {
        const keys = Object.keys(powerDistribution).filter(k => powerDistribution[k] > 0);
        let most_needed_type;
        if (keys.length === 0) {
            most_needed_type = is_blank_deck ? 'Blank' : selectedTypes.split('/')[0];
        } else {
            most_needed_type = keys.reduce((a, b) => powerDistribution[a] > powerDistribution[b] ? a : b);
        }

        const current_need = powerDistribution[most_needed_type] || 0;
        const remaining_slots = targetPower - deck.Power.length;

        const should_use_double = (
            double_power_count < DECK_RULES.power_card_limits.powerValue_2 &&
            current_need >= power_efficiency_threshold &&
            remaining_slots >= 2 &&
            current_need >= remaining_slots * 0.4 &&
            (powerCardsByType[most_needed_type] || []).some(c => (c.powerValue || 1) === 2)
        );

        if (should_use_double) {
            const card_to_add = (powerCardsByType[most_needed_type] || []).find(c => (c.powerValue || 1) === 2);
            deck.Power.push(card_to_add);
            powerDistribution[most_needed_type] = Math.max(0, powerDistribution[most_needed_type] - 2);
            double_power_count++;
        } else {
            let available_single = (powerCardsByType[most_needed_type] || []).filter(c => (c.powerValue || 1) === 1);
            let fallback_type = most_needed_type;
            if (available_single.length === 0) {
                available_single = (powerCardsByType['Blank'] || []).filter(c => (c.powerValue || 1) === 1);
                fallback_type = 'Blank';
            }
            if (available_single.length === 0) break;
            
            const card_to_add = available_single[0];
            deck.Power.push(card_to_add);
            powerDistribution[fallback_type] = Math.max(0, powerDistribution[fallback_type] - 1);

            if (is_blank_deck && fallback_type === 'Blank') {
                const blank_value_count = deck.Power.filter(p => p.powerType === 'Blank').reduce((sum, p) => sum + (p.powerValue || 1), 0);
                if (blank_value_count >= 12) powerDistribution['Blank'] = 0;
            }
        }
    }

    if (is_blank_deck) {
        const blank_power_count = deck.Power.filter(p => p.powerType === 'Blank').reduce((sum, p) => sum + (p.powerValue || 1), 0);
        const total_power_value = deck.Power.reduce((sum, p) => sum + (p.powerValue || 1), 0);
        const blank_percentage = total_power_value > 0 ? blank_power_count / total_power_value : 0;
        
        if (blank_percentage < 0.5) {
            const needed_blank = Math.max(1, Math.floor(total_power_value * 0.5) - blank_power_count);
            const non_blank_power = deck.Power.filter(p => p.powerType !== 'Blank');
            const blank_power_card_template = (powerCardsByType['Blank'] || []).find(c => (c.powerValue || 1) === 1);
            if (blank_power_card_template) {
                for (let i = 0; i < Math.min(needed_blank, non_blank_power.length); i++) {
                    const card_to_remove = non_blank_power[i];
                    deck.Power.splice(deck.Power.findIndex(p => p.script_uuid === card_to_remove.script_uuid), 1);
                    deck.Power.push(blank_power_card_template);
                }
            }
        }
    }

    // --- 4. SECRET CARD SELECTION ---
    const available_secrets = all_cards.filter(c => c.supertype === 'Secret');
    let scored_secrets = [];

    for (const secret of available_secrets) {
        const synergy_score = scoreSecretSynergy(secret, selectedTypes, deck.Creatures);
        if (synergy_score >= 0) {
            scored_secrets.push([secret, synergy_score]);
        }
    }
    scored_secrets.sort((a, b) => b[1] - a[1]);
    
    const secret_counts = defaultdict(() => 0);
    const terrain_counts = defaultdict(() => 0);
    let total_terrain_count = 0;

    while (deck.Secrets.length < targetSecrets && scored_secrets.length > 0) {
        const selection_pool_size = Math.min(15, scored_secrets.length);
        const [card_to_add, synergy_score] = scored_secrets[Math.floor(Math.random() * selection_pool_size)];
        
        const is_terrain = (card_to_add.subtypes || [null])[0] === 'Terrain';
        const card_name = card_to_add.name;
        const card_rarity = card_to_add.rarity;

        if (is_terrain && (total_terrain_count >= 4 || (!(card_name in terrain_counts) && Object.keys(terrain_counts).length >= 3))) {
            scored_secrets = scored_secrets.filter(s => s[0].script_uuid !== card_to_add.script_uuid);
            continue;
        }

        if (secret_counts[card_name] >= (DECK_RULES.secret_card_limits[card_rarity] || 1)) {
            scored_secrets = scored_secrets.filter(s => s[0].script_uuid !== card_to_add.script_uuid);
            continue;
        }

        deck.Secrets.push(card_to_add);
        secret_counts[card_name]++;
        
        if (is_terrain) {
            total_terrain_count++;
            terrain_counts[card_name]++;
        }
        scored_secrets = scored_secrets.filter(s => s[0].script_uuid !== card_to_add.script_uuid);
    }
        
    // --- 5. FINAL ADJUSTMENT ---
    while (deck.Creatures.length + deck.Power.length + deck.Secrets.length > 60) {
        if (deck.Power.length > targetPower) deck.Power.pop();
        else if (deck.Secrets.length > targetSecrets) deck.Secrets.pop();
        else deck.Creatures.pop();
    }
    
    while (deck.Creatures.length + deck.Power.length + deck.Secrets.length < 60) {
        let power_card_to_add = (powerCardsByType['Blank'] || [null])[0];
        if (!is_blank_deck) {
            const main_theme = selectedTypes.split('/')[0];
            const themed_power_card = (powerCardsByType[main_theme] || []).find(c => (c.powerValue || 1) === 1);
            power_card_to_add = themed_power_card || power_card_to_add;
        }
        if (power_card_to_add) deck.Power.push(power_card_to_add);
        else break;
    }
        
    return deck;
}


// --- DECK DISPLAY ---
function displayDeck(deck, deckTheme, archetype) {
    // Show output section
    outputDiv.style.display = 'block';

    // Set title and stats
    deckTitleH2.textContent = `${deckTheme} ${archetype} Deck`;
    
    const total = deck.Creatures.length + deck.Power.length + deck.Secrets.length;
    deckStatsP.textContent = `Total Cards: ${total} | Creatures: ${deck.Creatures.length}, Power: ${deck.Power.length}, Secrets: ${deck.Secrets.length}`;

    // Helper to populate a list
    const populateList = (listElement, cards, displayFormatter) => {
        listElement.innerHTML = '';
        if (cards.length === 0) {
            listElement.innerHTML = '<li>None</li>';
            return;
        }
        const counts = new Map();
        cards.forEach(card => {
            const key = displayFormatter(card);
            counts.set(key, (counts.get(key) || 0) + 1);
        });

        const uniqueKeys = [];
        const seen = new Set();
        cards.forEach(card => {
            const key = displayFormatter(card);
            if (!seen.has(key)) {
                uniqueKeys.push(key);
                seen.add(key);
            }
        });

        uniqueKeys.forEach(key => {
            const li = document.createElement('li');
            li.textContent = `${key} x${counts.get(key)}`;
            listElement.appendChild(li);
        });
    };

    // Populate Creatures
    deck.Creatures.sort((a, b) => (a.level || 0) - (b.level || 0) || a.name.localeCompare(b.name));
    populateList(creaturesListUl, deck.Creatures, c => `${c.name} (Lvl ${c.level || '?'}, ${(c.types || ['?'])[0]}, ${c.rarity})`);
    
    // Populate Power
    populateList(powerListUl, deck.Power, p => `${p.powerType} Power ${(p.powerValue || 1) === 2 ? '(x2)' : ''} (${p.rarity})`);

    // Populate Secrets
    populateList(secretsListUl, deck.Secrets, s => `${s.name} (${(s.subtypes || ['?'])[0]}, ${s.rarity})`);
}

// --- INITIALIZATION AND EVENT LISTENERS ---
async function initialize() {
    // Populate archetypes
    Object.entries(DECK_ARCHETYPES).forEach(([name, data], index) => {
        const input = document.createElement('input');
        input.type = 'radio';
        input.id = `archetype-${name}`;
        input.name = 'archetype';
        input.value = name;
        if (index === 0) input.checked = true;

        const label = document.createElement('label');
        label.htmlFor = `archetype-${name}`;
        label.textContent = name;
        label.title = data.description;
        
        archetypeOptionsDiv.appendChild(input);
        archetypeOptionsDiv.appendChild(label);
    });

    const cardDataUrl = 'https://raw.githubusercontent.com/nerdrealm/mystik_builder/main/cardProfiles.json';
    all_cards = await loadCardsFromJson(cardDataUrl);

    if (all_cards) {
        companion_map = getCompanionMap(all_cards);
        // CHANGED SUCCESS MESSAGE
        statusDiv.textContent = `Ready to build. Please select a theme and archetype below.`;
        statusDiv.style.color = 'var(--color-green-status)';
        generateBtn.disabled = false;
    } else {
        // Error message is already set in loadCardsFromJson
        generateBtn.disabled = true;
    }

    // Attach event listeners
    generateBtn.addEventListener('click', () => {
        const rawThemeInput = themeInput.value.trim();
        if (!rawThemeInput) {
            alert("Please enter a Deck Type Theme.");
            return;
        }

        const normalizedParts = rawThemeInput.split('/').map(part => {
            const p = part.trim();
            return p.charAt(0).toUpperCase() + p.slice(1).toLowerCase();
        });
        const deckTheme = normalizedParts.join('/');
        
        const archetype = document.querySelector('input[name="archetype"]:checked').value;
        
        statusDiv.textContent = `Building a(n) ${archetype} deck with the ${deckTheme} theme...`;
        statusDiv.style.color = 'var(--color-cyan-status)';

        // Use setTimeout to allow the UI to update before the heavy computation
        setTimeout(() => {
            try {
                const deck = buildStrategicDeck(deckTheme, archetype);
                displayDeck(deck, deckTheme, archetype);
                statusDiv.textContent = "Deck generated successfully!";
                statusDiv.style.color = 'var(--color-green-status)';

            } catch (e) {
                statusDiv.textContent = "An error occurred during deck generation. See console for details.";
                statusDiv.style.color = 'var(--color-red-status)';
                console.error(e);
            }
        }, 50);
    });
}

initialize();

});
</script>

</body>
</html>
