<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystik Creatures Deck Builder</title>
    <style>
        :root {
            --bg-color: #1e1e1e; /* Charcoal Black */
            --container-bg: #2d2d2d; /* Slightly Lighter Charcoal */
            --input-bg: #3c3c3c;
            --text-color: #FFD700; /* Golden Yellow */
            --text-light: #dcdcdc;
            --border-color: #FFD700; /* Golden Yellow */
            --btn-color: #FFD700; /* Golden Yellow */
            --btn-text-color: #1e1e1e; /* Dark text on yellow button */
            --btn-hover-color: #ffeb99; /* Lighter yellow for hover */
            
            /* Status Colors */
            --color-yellow-status: #f1c40f;
            --color-red-status: #e74c3c;
            --color-green-status: #2ecc71;
            --color-cyan-status: #1abc9c;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .main-container {
            width: 100%;
            max-width: 1200px;
            background-color: var(--container-bg);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.25);
        }

        header {
            display: flex; 
            align-items: center; 
            justify-content: center; 
            margin-bottom: 25px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 20px;
        }

        header img {
            max-width: 200px; 
            margin-right: 25px; 
        }

        header h1 {
            color: var(--text-color);
            margin: 0;
            font-size: 2.5em; 
            text-shadow: 0 0 5px var(--text-color);
        }

        #status {
            text-align: center;
            padding: 10px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
            color: var(--color-yellow-status);
            border: 1px solid;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background-color: var(--bg-color);
            border-radius: 8px;
        }
        
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }

            /* --- MOBILE OPTIMIZATIONS START --- */
            body {
                padding: 10px;
            }

            .main-container {
                padding: 15px;
            }
            
            header {
                flex-direction: column;
                text-align: center;
                padding-bottom: 15px;
            }

            header img {
                max-width: 150px;
                margin-right: 0;
                margin-bottom: 15px;
            }

            header h1 {
                font-size: 2em;
            }

            .action-button {
                padding: 12px;
                font-size: 1.1em;
            }

            /* Adjust card list title and sort buttons for mobile */
            .card-list h3 {
                display: flex;
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .sort-controls {
                margin-left: 0;
            }
            /* --- MOBILE OPTIMIZATIONS END --- */
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            margin-bottom: 5px; 
            font-weight: bold;
            color: var(--text-color);
        }

        .theme-hint {
            font-size: 0.85em;
            color: #bbbbbb;
            margin-top: 0;
            margin-bottom: 10px;
            font-style: italic;
        }

        .control-group input[type="text"] {
            padding: 12px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-light);
            font-size: 1em;
        }
        
        .archetype-options {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .archetype-options label {
            cursor: pointer;
            padding: 10px 15px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            transition: all 0.2s ease-in-out;
        }
        
        .archetype-options input[type="radio"] {
            display: none;
        }
        
        .archetype-options input[type="radio"]:checked + label {
            background-color: var(--btn-color);
            color: var(--btn-text-color);
            font-weight: bold;
            box-shadow: 0 0 10px var(--btn-color);
        }

        #archetype-Balanced:checked + label {
            background-color: var(--color-green-status);
            box-shadow: 0 0 10px var(--color-green-status);
            color: var(--btn-text-color);
            border-color: var(--color-green-status);
        }
        #archetype-Aggro:checked + label {
            background-color: var(--color-red-status);
            box-shadow: 0 0 10px var(--color-red-status);
            color: var(--text-light);
            border-color: var(--color-red-status);
        }
        #archetype-Control:checked + label {
            background-color: var(--color-yellow-status);
            box-shadow: 0 0 10px var(--color-yellow-status);
            color: var(--btn-text-color);
            border-color: var(--color-yellow-status);
        }
        #archetype-Energy:checked + label {
            background-color: var(--color-cyan-status);
            box-shadow: 0 0 10px var(--color-cyan-status);
            color: var(--btn-text-color);
            border-color: var(--color-cyan-status);
        }


        .action-button {
            grid-column: 1 / -1;
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            color: var(--btn-text-color);
            background-color: var(--btn-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .action-button:hover {
            background-color: var(--btn-hover-color);
        }
        
        .action-button:disabled {
            background-color: #555;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
            border-color: #555;
        }

        #output {
            display: none; 
            padding-bottom: 20px;
        }
        
        #caution-message {
            text-align: center;
            padding: 15px;
            background-color: var(--bg-color);
            border: 2px solid var(--color-yellow-status);
            border-radius: 8px;
            margin-bottom: 20px;
        }

        #caution-message h3 {
            margin: 0 0 10px 0;
            font-weight: bold;
            text-transform: uppercase;
            color: var(--color-yellow-status);
        }

        #caution-message p {
            margin: 0;
            line-height: 1.5;
            color: var(--text-light);
        }
        
        #caution-message p:first-of-type {
            margin-bottom: 10px;
        }

        #deck-summary {
            text-align: center;
            padding: 15px;
            background-color: var(--bg-color);
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        #deck-summary h2 {
            margin: 0 0 10px 0;
            color: var(--text-color);
        }
        
        #deck-list-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .card-list {
            background-color: var(--bg-color);
            padding: 15px;
            border-radius: 8px;
        }
        
        .card-list h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--border-color);
            color: var(--text-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        
        .card-list ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        
        .card-list li {
            padding: 5px 0;
            border-bottom: 1px solid var(--input-bg);
        }

        .card-list li:last-child {
            border-bottom: none;
        }

        .sort-controls {
            display: inline-flex;
            gap: 8px;
            margin-left: 15px;
            vertical-align: middle;
        }
        .sort-btn {
            background-color: var(--input-bg);
            color: var(--text-light);
            border: 1px solid var(--border-color);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            cursor: pointer;
        }
        .sort-btn:hover {
            background-color: var(--border-color);
            color: var(--btn-text-color);
        }

        #json-generator-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: center; 
            gap: 20px; 
        }
        
        .code-block-wrapper {
            width: 100%;
            max-width: 800px;
            border: 1px solid var(--input-bg);
            border-radius: 8px;
            background-color: #111;
            overflow: hidden; 
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--input-bg);
            padding: 8px 15px;
            color: var(--text-light);
            font-size: 0.9em;
        }

        #copy-json-btn {
            background: none;
            border: 1px solid #777;
            color: #ccc;
            padding: 4px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.2em; /* Increased size for icon */
            transition: all 0.2s;
            line-height: 1; /* Helps vertical alignment */
        }
        #copy-json-btn:hover {
            background-color: #555;
            color: white;
            border-color: #999;
        }

        .code-body {
            padding: 15px;
        }

        #json-output {
            background: none;
            color: #dcdcdc;
            padding: 0;
            margin: 0;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            border: none;
        }
        
        #json-warning {
            padding: 12px 15px;
            background-color: rgba(241, 196, 15, 0.1); 
            border-top: 1px solid var(--color-yellow-status);
            color: #f3dca1;
            font-size: 0.9em;
            line-height: 1.4;
        }
        #json-warning strong {
            color: var(--color-yellow-status);
        }

        /* --- PASSKEY MODAL STYLES START --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: var(--container-bg);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid var(--border-color);
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
        }

        .modal-content h2 {
            margin-top: 0;
            color: var(--color-yellow-status);
        }

        .passkey-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 25px 0;
        }

        .passkey-input {
            width: 50px;
            height: 60px;
            text-align: center;
            font-size: 2em;
            font-weight: bold;
            color: var(--text-light);
            background-color: var(--input-bg);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            outline: none;
        }

        .passkey-input:focus {
            box-shadow: 0 0 10px var(--btn-color);
        }

        #passkey-error {
            color: var(--color-red-status);
            font-weight: bold;
            height: 20px; /* Reserve space to prevent layout shift */
            visibility: hidden;
        }
        /* --- PASSKEY MODAL STYLES END --- */

    </style>
</head>
<body>

    <div class="main-container">
        <header>
            <img src="https://raw.githubusercontent.com/nerdrealm/mystik_builder/main/MystikLogo-PNG.png" 
                 alt="Mystik Creatures Logo" 
                 onerror="this.style.display='none'; this.nextSibling.style.display='block';">
            <p style="display:none; color: var(--color-red-status);">Logo failed to load. Make sure 'MystikLogo-PNG.png' exists in your public GitHub repository.</p>
            <h1>Mystik Creatures Deck Builder</h1>
        </header>

        <div id="status">Loading card data... Please wait.</div>

        <div class="controls">
            <div class="control-group">
                <label for="deckTheme">Deck Type Theme</label>
                <p class="theme-hint">Types: Fire, Water, Dark, Thunder, Earth, Wind, Forest, Light, or Blank. <br>Combine two or more with a slash, space, or comma.</p>
                <input type="text" id="deckTheme" placeholder="Enter a theme here...">
            </div>

            <div class="control-group">
                <label>Deck Archetype</label>
                <div id="archetype-options" class="archetype-options">
                    <!-- Options will be populated by JS -->
                </div>
            </div>

            <button id="generate-btn" class="action-button" disabled>Generate Deck</button>
        </div>

        <div id="caution-message" style="display: none;">
            <h3>CAUTION</h3>
            <p>Some cards in this deck may not fit your build or strategy, and others may not meet official deck-building rules.</p>
            <p>Always tailor your deck around your core Creatures, and be sure to follow all level, rarity, and card limits.</p>
        </div>

        <div id="output">
            <div id="deck-summary">
                <h2 id="deck-title"></h2>
                <p id="deck-stats"></p>
            </div>
            <div id="deck-list-container">
                <div class="card-list">
                    <h3 id="creatures-title">Creatures</h3>
                    <ul id="creatures-list"></ul>
                </div>
                <div class="card-list">
                    <h3 id="power-title">Power</h3>
                    <ul id="power-list"></ul>
                </div>
                <div class="card-list">
                    <h3 id="secrets-title">Secrets</h3>
                    <ul id="secrets-list"></ul>
                </div>
            </div>
        </div>
        <!-- JSON generator will be inserted here by JS -->
    </div>
    <!-- Passkey Modal will be inserted here by JS -->

<script>
document.addEventListener('DOMContentLoaded', () => {

// --- CONFIGURATION & DECK RULES ---
const DECK_RULES = {
    "deck_size": 60,
    "creature_card_limits": { "Common": 4, "Uncommon": 3, "Rare": 2, "UltraRare": 2 },
    "level_10_limits": { "total": 4 },
    "power_card_limits": { "powerValue_1": Infinity, "powerValue_2": 5 },
    "secret_card_limits": { "Common": 3, "Uncommon": 2, "Rare": 1 }
};

const DECK_ARCHETYPES = {
    "Balanced": { 
        "creatures": { "base": 0.40, "flex": 0.04 }, // ~22 to 26 creatures
        "secrets":   { "base": 0.35, "flex": 0.04 }, // ~19 to 23 secrets
        "description": "A well-rounded deck" 
    },
    "Aggro": { 
        "creatures": { "base": 0.50, "flex": 0.05 }, // ~27 to 33 creatures
        "secrets":   { "base": 0.25, "flex": 0.03 }, // ~13 to 17 secrets
        "description": "Creature-heavy and aggressive" 
    },
    "Control": { 
        "creatures": { "base": 0.30, "flex": 0.03 }, // ~16 to 20 creatures
        "secrets":   { "base": 0.45, "flex": 0.05 }, // ~24 to 30 secrets
        "description": "Secret-heavy and disruptive" 
    },
    "Energy": { 
        "creatures": { "base": 0.35, "flex": 0.03 }, // ~19 to 23 creatures
        "secrets":   { "base": 0.30, "flex": 0.04 }, // ~16 to 20 secrets
        "description": "Power-heavy for big plays" 
    }
};


const ARCHETYPE_COLORS = {
    "Balanced": "var(--color-green-status)",
    "Aggro": "var(--color-red-status)",
    "Control": "var(--color-yellow-status)",
    "Energy": "var(--color-cyan-status)"
};

const TERRAIN_TYPE_COMPATIBILITY = {
    "Ancient Forests of Rehm": ["Forest"], "Aquatic Paradise": ["Water", "Forest"], "Dark Shadows": ["Dark"],
    "Huricanes off Jimbora": ["Thunder"], "Infernal Pits of Crom": ["Fire"], "Lights of Nura": ["Light"],
    "Mountains of Eurotha": ["Earth"], "Oceans of Nimbitu": ["Water"], "Pixie Forest": ["Forest"],
    "Poisonous Swamp": ["Earth", "Dark"], "Rough Seas": ["Water"], "Sacred Grounds": ["Thunder", "Light"],
    "Sandstorm": ["Earth"], "Scorched Fields": ["Wind", "Fire"], "Shadow Plains": ["Dark"],
    "Southern Winds of Us'ah": ["Wind"], "Star of Septeptus": ["Light"], "Stomy Skies": ["Thunder"],
    "Torn Wastelands": ["All"], "Volcanoes of Westu'ra": ["Fire"], "Winds off the Coast": ["Wind"]
};

const BOSS_COMPANION_MAP = {
    "Arcana Temptress": ["Arcana Apprentice"], "Dracoleón": ["Nemean Lion"], "Hydra": ["Nereus"],
    "Infinity Mage": ["Infinity Apprentice"], "Phoenix, the Rising": ["Phoenic"], "Serpopard": ["Anuket"],
    "Werelephant": ["Pebblephant"], "Zombified Dragon": ["Dragon Tamer"],
    "Divine Beast Panterus": ["Winged Beast U'ru", "Winged Beast Wai'ku", "Winged Beast Ra'zu"],
    "Astraea": [], "Aurora, the Paladin": [], "Avani": [], "Bristleback": [], "Cloudpiercer": [], "Eamonn": [],
    "Ephemeral Empress": [], "Hikaru, Thunderflame": [], "Ignimia": [], "Iškugriff": [], "Isxóhe": [], "Kaia": [],
    "Kuroen": [], "Laviathron": [], "Lilith, Forest Pixie": [], "Malum, the Damned": [], "Raitei": [],
    "Rann, the Wretched": [], "Strix Arenaeus": [], "Tempestas": [], "Tetsu Yami": [], "Wilderfang": [], "Wolfdrake": []
};

const BANNED_SECRET_CARDS = [
    "Aquatic Conversion", "Celestial Storm", "Corrupt Evolution", "Divine Transformation",
    "Elemental Infusion", "Infernal Transmutation", "Mystik Forestry", "Primeval Mutation",
    "Windy Metamorphosis", "Elemental Break"
];


// --- GLOBAL VARIABLES & DOM ELEMENTS ---
let all_cards = [];
let companion_map = {};
let currentDeck = null;
let currentDeckTheme = '';

const statusDiv = document.getElementById('status');
const generateBtn = document.getElementById('generate-btn');
const themeInput = document.getElementById('deckTheme');
const archetypeOptionsDiv = document.getElementById('archetype-options');
const outputDiv = document.getElementById('output');
const deckTitleH2 = document.getElementById('deck-title');
const deckStatsP = document.getElementById('deck-stats');
const creaturesListUl = document.getElementById('creatures-list');
const powerListUl = document.getElementById('power-list');
const secretsListUl = document.getElementById('secrets-list');
const creaturesTitleH3 = document.getElementById('creatures-title');
const powerTitleH3 = document.getElementById('power-title');
const secretsTitleH3 = document.getElementById('secrets-title');
const cautionDiv = document.getElementById('caution-message');

const defaultdict = (defaultValueFactory) => new Proxy({}, {
    get: (target, name) => name in target ? target[name] : (target[name] = defaultValueFactory())
});

// --- UTILITY FUNCTIONS ---
const shuffle = (array) => {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
};

// --- DATA LOADING & INITIALIZATION ---
async function loadCardsFromJson(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        const unique_cards = [];
        const seen = new Set();
        for (const card of data) {
            if (!card.id) {
                console.warn(`Card "${card.name}" is missing an 'id' field, which is required for JSON export.`);
            }
            card.script_uuid = crypto.randomUUID();
            const identifier = `${card.name}|${card.collectionNumber}`;
            if (!seen.has(identifier)) {
                unique_cards.push(card);
                seen.add(identifier);
            }
        }
        return unique_cards;
    } catch (e) {
        statusDiv.innerHTML = `<strong>ERROR:</strong> Failed to fetch card data.`;
        statusDiv.style.color = 'var(--color-red-status)';
        console.error("Error loading card data:", e);
        return null;
    }
}

// --- SYNERGY & HELPER FUNCTIONS ---
function getCompanionMap(cards) {
    const newCompanionMap = defaultdict(() => ({ creatures: [], secrets: [] }));
    for (const card of cards) {
        if (card.supertype !== 'Creature') continue;
        for (const ability of card.abilities || []) {
            for (const prereq of ability.prerequisites || []) {
                if (prereq.type === 'SacrificeSpecificCreature') newCompanionMap[card.name].creatures.push(prereq.creatureName);
                else if (prereq.type === 'PlaySpecificCard') newCompanionMap[card.name].secrets.push(prereq.cardName);
                else if (prereq.type === 'HasCreatureInPlay') newCompanionMap[card.name].creatures.push(prereq.creatureName);
            }
        }
    }
    return newCompanionMap;
}

function analyzePowerRequirements(creatures) {
    const powerNeeds = defaultdict(() => 0);
    for (const creature of creatures) {
        for (const attack of creature.attacks || []) {
            for (const cost of attack.cost || []) {
                powerNeeds[cost.PowerType] += cost.count;
            }
        }
    }
    return powerNeeds;
}

function scoreCreatureSynergy(card, deckTheme) {
    let score = Math.random() * 50; // Increased random factor
    const cardTypes = card.types || [];
    const themeTypes = deckTheme.split('/');
    if (!themeTypes.some(t => cardTypes.includes(t))) return -1;
    score += 50;
    if (themeTypes.length > 1 && themeTypes.every(t => cardTypes.includes(t))) score += 40;
    if (Object.values(companion_map).some(v => v.creatures.includes(card.name))) score += 30; // Is a companion
    if (card.name in companion_map) score += 30; // Is a boss
    if (card.rarity === 'Rare') score += 15;
    if (card.rarity === 'UltraRare') score += 25;
    if ((card.level || 0) >= 7) score += 10;
    return score;
}

function scoreSecretSynergy(card, deckTheme, creaturesInDeck) {
    const cardName = card.name || '';
    if (BANNED_SECRET_CARDS.includes(cardName)) return -1;
    for (const bossName in companion_map) {
        if ((companion_map[bossName].secrets || []).includes(cardName)) {
            return creaturesInDeck.some(c => c.name === bossName) ? 1000 : -1;
        }
    }
    let score = Math.random() * 45; // Increased random factor
    const themeTypes = deckTheme.split('/');
    if ((card.subtypes || [null])[0] === 'Terrain') {
        if (deckTheme === 'Blank') return -1;
        const validTypes = TERRAIN_TYPE_COMPATIBILITY[cardName] || [];
        if (validTypes.includes("All") || themeTypes.some(theme => validTypes.includes(theme))) {
            score += 80;
        } else {
            return -1;
        }
    } else {
        const effectText = (card.effectText || '').toLowerCase();
        for (const theme of themeTypes) {
            if (effectText.includes(theme.toLowerCase())) score += 25;
        }
    }
    return score;
}

function getWeightedRandomBossCount() {
    const weights = { 0: 10, 1: 30, 2: 40, 3: 15, 4: 5 };
    const totalWeight = Object.values(weights).reduce((sum, weight) => sum + weight, 0);
    let random = Math.random() * totalWeight;
    for (const [count, weight] of Object.entries(weights)) {
        random -= weight;
        if (random <= 0) return parseInt(count, 10);
    }
    return 2; // Fallback
}

function selectFromTieredPool(pool) {
    if (!pool || pool.length === 0) return null;

    const tier1_end = Math.floor(pool.length * 0.15); // Top 15% (S-Tier)
    const tier2_end = Math.floor(pool.length * 0.40); // Next 25% (A-Tier)
    const tier3_end = Math.floor(pool.length * 0.75); // Next 35% (B-Tier)

    const rand = Math.random();
    let selectedTier;

    if (rand < 0.50) selectedTier = pool.slice(0, tier1_end);
    else if (rand < 0.80) selectedTier = pool.slice(tier1_end, tier2_end);
    else if (rand < 0.95) selectedTier = pool.slice(tier2_end, tier3_end);
    else selectedTier = pool.slice(tier3_end);
    
    if (selectedTier.length === 0) selectedTier = pool;

    const randomIndex = Math.floor(Math.random() * selectedTier.length);
    return selectedTier[randomIndex];
}


function buildStrategicDeck(selectedTypes, archetype_name) {
    const deck = { "Creatures": [], "Power": [], "Secrets": [] };
    const archetype = DECK_ARCHETYPES[archetype_name];
    const is_blank_deck = (selectedTypes === 'Blank');

    const getRandomCount = (spec) => {
        const random_flex = (Math.random() * 2 - 1) * spec.flex;
        return Math.round(DECK_RULES.deck_size * (spec.base + random_flex));
    };
    
    let totalTargetCreatures = getRandomCount(archetype.creatures);
    let targetSecrets = getRandomCount(archetype.secrets);
    let targetPower = DECK_RULES.deck_size - totalTargetCreatures - targetSecrets;
    
    const creatureCounts = defaultdict(() => 0);
    const themeTypes = selectedTypes.split('/');

    // 1. Fill the Lvl 10 (Boss) Bucket
    const num_bosses_to_add = getWeightedRandomBossCount();
    let bosses_added_this_run = [];
    let potential_bosses = all_cards.filter(c => 
        c.supertype === 'Creature' && c.level === 10 && (c.rarity === 'UltraRare' || c.rarity === 'Rare') &&
        (is_blank_deck || (c.types || []).some(t => themeTypes.includes(t)))
    );

    if (potential_bosses.length > 0) {
        let unique_boss_pool = shuffle(Array.from(new Map(potential_bosses.map(c => [c.name, c])).values()));
        while (deck.Creatures.filter(c => c.level === 10).length < num_bosses_to_add && unique_boss_pool.length > 0) {
            const chosen_boss = unique_boss_pool.pop();
            if (!chosen_boss) continue;
            if (creatureCounts[chosen_boss.name] < DECK_RULES.creature_card_limits.UltraRare) {
                 deck.Creatures.push(chosen_boss);
                 creatureCounts[chosen_boss.name]++;
                 if (!bosses_added_this_run.find(b => b.name === chosen_boss.name)) {
                     bosses_added_this_run.push(chosen_boss);
                 }
            }
            if (deck.Creatures.filter(c => c.level === 10).length < num_bosses_to_add && 
                creatureCounts[chosen_boss.name] < DECK_RULES.creature_card_limits.UltraRare && Math.random() < 0.6) {
                deck.Creatures.push(chosen_boss);
                creatureCounts[chosen_boss.name]++;
            }
        }
    }

    // 2. Add Companions for the chosen bosses
    for (const boss of bosses_added_this_run) {
        if (boss.name in BOSS_COMPANION_MAP) {
            for (const comp_name of BOSS_COMPANION_MAP[boss.name]) {
                if (deck.Creatures.length >= totalTargetCreatures) break;
                const comp_card = all_cards.find(c => c.name === comp_name);
                if (comp_card && creatureCounts[comp_name] < (DECK_RULES.creature_card_limits[comp_card.rarity] || 1)) {
                    deck.Creatures.push(comp_card);
                    creatureCounts[comp_name]++;
                }
            }
        }
    }
    
    // Create sorted pools for remaining creatures
    const pool7_9 = all_cards.filter(c => c.supertype === 'Creature' && c.level >= 7 && c.level <= 9 && (is_blank_deck || (c.types || []).some(t => themeTypes.includes(t)))).map(c => [c, scoreCreatureSynergy(c, selectedTypes)]).sort((a, b) => b[1] - a[1]);
    const pool4_6 = all_cards.filter(c => c.supertype === 'Creature' && c.level >= 4 && c.level <= 6 && (is_blank_deck || (c.types || []).some(t => themeTypes.includes(t)))).map(c => [c, scoreCreatureSynergy(c, selectedTypes)]).sort((a, b) => b[1] - a[1]);
    const pool1_3 = all_cards.filter(c => c.supertype === 'Creature' && c.level >= 1 && c.level <= 3 && (is_blank_deck || (c.types || []).some(t => themeTypes.includes(t)))).map(c => [c, scoreCreatureSynergy(c, selectedTypes)]).sort((a, b) => b[1] - a[1]);

    // 3. Fill the rest of the creature slots using the new Wildcard logic
    // MODIFICATION: Increased spice chance for more variety
    const SPICE_CHANCE = 0.40; // 40% chance to pick a truly random card
    while(deck.Creatures.length < totalTargetCreatures) {
        const rand = Math.random();
        let pool_to_use;
        if (rand < 0.5 && pool1_3.length > 0) pool_to_use = pool1_3;
        else if (rand < 0.85 && pool4_6.length > 0) pool_to_use = pool4_6;
        else if(pool7_9.length > 0) pool_to_use = pool7_9;
        else pool_to_use = pool1_3.length > 0 ? pool1_3 : pool4_6;

        if (!pool_to_use || pool_to_use.length === 0) break;
        
        let card_to_add;
        // Wildcard "Spice" Selection
        if (Math.random() < SPICE_CHANCE) {
            // Pick a completely random card from the chosen level bucket
            const randomIndex = Math.floor(Math.random() * pool_to_use.length);
            card_to_add = pool_to_use[randomIndex][0];
        } else {
            // Normal tiered pick
            const selection = selectFromTieredPool(pool_to_use);
            if (selection) card_to_add = selection[0];
        }

        if (card_to_add && creatureCounts[card_to_add.name] < (DECK_RULES.creature_card_limits[card_to_add.rarity] || 1)) {
            deck.Creatures.push(card_to_add);
            creatureCounts[card_to_add.name]++;
        }
    }
    
    // --- POWER CARD SELECTION ---
    const power_needs = analyzePowerRequirements(deck.Creatures);
    let power_tasks = [];
    for (const type in power_needs) {
        for (let i = 0; i < power_needs[type]; i++) power_tasks.push(type);
    }
    const allCreatureTypesInDeck = [...new Set(deck.Creatures.flatMap(c => c.types || []))];
    allCreatureTypesInDeck.forEach(type => {
        if (!power_needs[type]) { for(let i = 0; i < 2; i++) power_tasks.push(type); }
    });
    shuffle(power_tasks);
    const powerCardsByType = defaultdict(() => []);
    all_cards.filter(c => c.supertype === 'Power').forEach(c => powerCardsByType[c.powerType].push(c));
    let double_power_count = 0;
    while (deck.Power.length < targetPower) {
        if (power_tasks.length === 0) {
            let fill_type = is_blank_deck ? 'Blank' : (allCreatureTypesInDeck[0] || 'Blank');
            const card = powerCardsByType[fill_type].find(c => (c.powerValue || 1) === 1) || powerCardsByType['Blank'].find(c => (c.powerValue || 1) === 1);
            if (card) deck.Power.push(card); else break;
            continue;
        }
        const next_power_type = power_tasks.shift();
        const use_double = (double_power_count < DECK_RULES.power_card_limits.powerValue_2 && 
                            power_tasks.filter(t => t === next_power_type).length > 0 && 
                            powerCardsByType[next_power_type].some(c => (c.powerValue || 1) === 2));
        if (use_double) {
            const card_to_add = powerCardsByType[next_power_type].find(c => (c.powerValue || 1) === 2);
            deck.Power.push(card_to_add);
            double_power_count++;
            const second_task_index = power_tasks.findIndex(t => t === next_power_type);
            if(second_task_index > -1) power_tasks.splice(second_task_index, 1);
        } else {
            const card_to_add = powerCardsByType[next_power_type].find(c => (c.powerValue || 1) === 1) || powerCardsByType['Blank'].find(c => (c.powerValue || 1) === 1);
            if(card_to_add) deck.Power.push(card_to_add);
        }
    }

    // --- SECRET CARD SELECTION ---
    let secret_pool = all_cards
        .filter(c => c.supertype === 'Secret')
        .map(secret => [secret, scoreSecretSynergy(secret, selectedTypes, deck.Creatures)])
        .filter(([_, score]) => score >= 0)
        .sort((a, b) => b[1] - a[1]);

    const secret_counts = defaultdict(() => 0);
    while (deck.Secrets.length < targetSecrets && secret_pool.length > 0) {
        let card_to_add;
        // Wildcard "Spice" Selection
        if (Math.random() < SPICE_CHANCE) {
            const randomIndex = Math.floor(Math.random() * secret_pool.length);
            card_to_add = secret_pool[randomIndex][0];
        } else {
            const selection = selectFromTieredPool(secret_pool);
            if (selection) card_to_add = selection[0];
        }

        if(!card_to_add) continue;
        
        const { name: card_name, rarity: card_rarity, subtypes: card_subtypes = [] } = card_to_add;
        if (secret_counts[card_name] >= (DECK_RULES.secret_card_limits[card_rarity] || 1)) continue;
        
        const current_terrain_count = deck.Secrets.filter(c => (c.subtypes || []).includes('Terrain')).length;
        const terrain_names = new Set(deck.Secrets.filter(c => (c.subtypes || []).includes('Terrain')).map(c => c.name));
        if (card_subtypes.includes('Terrain') && (current_terrain_count >= 4 || (!terrain_names.has(card_name) && terrain_names.size >= 3))) continue;
        
        deck.Secrets.push(card_to_add);
        secret_counts[card_name]++;
    }
        
    // --- FINAL DECK SIZE ADJUSTMENT ---
    while (deck.Creatures.length + deck.Power.length + deck.Secrets.length < DECK_RULES.deck_size) {
        const card = powerCardsByType['Blank'].find(c => (c.powerValue || 1) === 1);
        if(card) deck.Power.push(card); else break;
    }
     while (deck.Creatures.length + deck.Power.length + deck.Secrets.length > DECK_RULES.deck_size) {
        if(deck.Power.length > targetPower) deck.Power.pop();
        else if (deck.Secrets.length > targetSecrets) deck.Secrets.pop();
        else if (deck.Creatures.length > totalTargetCreatures) deck.Creatures.pop();
        else {
            if (deck.Power.length > deck.Secrets.length && deck.Power.length > deck.Creatures.length) deck.Power.pop();
            else if (deck.Secrets.length > deck.Creatures.length) deck.Secrets.pop();
            else deck.Creatures.length > 0 ? deck.Creatures.pop() : deck.Power.pop();
        }
    }
        
    return deck;
}

const populateList = (listElement, cards, displayFormatter) => {
    listElement.innerHTML = '';
    if (cards.length === 0) { listElement.innerHTML = '<li>None</li>'; return; }
    const counts = new Map();
    cards.forEach(card => {
        const key = displayFormatter(card);
        counts.set(key, (counts.get(key) || 0) + 1);
    });
    const uniqueKeys = [];
    const seen = new Set();
    cards.forEach(card => {
        const key = displayFormatter(card);
        if (!seen.has(key)) {
            uniqueKeys.push(key);
            seen.add(key);
        }
    });

    uniqueKeys.forEach(key => {
        const li = document.createElement('li');
        li.textContent = `${key} x${counts.get(key)}`;
        listElement.appendChild(li);
    });
};

function renderCreatureList(sortOrder = 'asc') {
    if (!currentDeck) return;
    const sortedCreatures = [...currentDeck.Creatures]; 
    
    if (sortOrder === 'asc') {
        sortedCreatures.sort((a, b) => (a.level || 0) - (b.level || 0) || a.name.localeCompare(b.name));
    } else { // desc
        sortedCreatures.sort((a, b) => (b.level || 0) - (a.level || 0) || a.name.localeCompare(b.name));
    }
    
    populateList(creaturesListUl, sortedCreatures, c => `${c.name} (Lvl ${c.level || '?'}, ${(c.types || ['?'])[0]}, ${c.rarity})`);
}

function displayDeck(deck, deckTheme, archetype) {
    outputDiv.style.display = 'block';
    const color = ARCHETYPE_COLORS[archetype] || 'var(--text-color)';
    deckTitleH2.textContent = `${deckTheme} ${archetype} Deck`;
    [deckTitleH2, creaturesTitleH3, powerTitleH3, secretsTitleH3].forEach(el => el.style.color = color);
    const total = deck.Creatures.length + deck.Power.length + deck.Secrets.length;
    deckStatsP.textContent = `Total Cards: ${total} | Creatures: ${deck.Creatures.length}, Power: ${deck.Power.length}, Secrets: ${deck.Secrets.length}`;
    
    let oldSortControls = document.getElementById('creature-sort-controls');
    if (oldSortControls) oldSortControls.remove();

    const sortControlsDiv = document.createElement('div');
    sortControlsDiv.id = 'creature-sort-controls';
    sortControlsDiv.className = 'sort-controls';
    
    const sortAscBtn = document.createElement('button');
    sortAscBtn.textContent = 'Sort 1-10';
    sortAscBtn.className = 'sort-btn';
    sortAscBtn.onclick = () => renderCreatureList('asc');
    
    const sortDescBtn = document.createElement('button');
    sortDescBtn.textContent = 'Sort 10-1';
    sortDescBtn.className = 'sort-btn';
    sortDescBtn.onclick = () => renderCreatureList('desc');
    
    sortControlsDiv.appendChild(sortAscBtn);
    sortControlsDiv.appendChild(sortDescBtn);
    creaturesTitleH3.appendChild(sortControlsDiv);
    
    renderCreatureList('asc');
    populateList(powerListUl, deck.Power, p => `${p.powerType} Power ${(p.powerValue || 1) === 2 ? '(x2)' : ''} (${p.rarity})`);
    populateList(secretsListUl, deck.Secrets, s => `${s.name} (${(s.subtypes || ['?'])[0]}, ${s.rarity})`);
}

function generateDeckName() {
    const prefixes = ["Crimson", "Azure", "Verdant", "Shadow", "Gilded", "Ironclad", "Howling", "Silent", "Arcane", "Solar"];
    const suffixes = ["Fury", "Guard", "Storm", "Whisper", "Legacy", "Dawn", "Vengeance", "Heart", "Rage", "Dominion"];
    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
    return `${prefix} ${suffix}`;
}

function formatDeckAsJson(deck, deckTheme) {
    try {
        const allDeckCards = [...deck.Creatures, ...deck.Power, ...deck.Secrets];
        const cardCounts = new Map();
        for (const card of allDeckCards) {
            if (card.id === undefined) throw new Error(`Card "${card.name}" is missing a required 'id' field.`);
            const cardId = parseInt(card.id, 10);
            cardCounts.set(cardId, (cardCounts.get(cardId) || 0) + 1);
        }
        const formattedCards = Array.from(cardCounts.entries());
        const outputDeck = {
            id: String(Math.floor(Math.random() * (9999 - 2000 + 1) + 2000)),
            name: generateDeckName(),
            types: deckTheme.split('/'),
            cards: formattedCards,
            setCode: "MC01"
        };
        const baseJsonString = JSON.stringify(outputDeck, null, 2);
        const indentedLines = baseJsonString.split('\n').map(line => '  ' + line);
        return indentedLines.join('\n') + ',';
    } catch (e) {
        console.error("Error formatting deck as JSON:", e);
        statusDiv.textContent = `Error: ${e.message} Cannot generate JSON.`;
        statusDiv.style.color = 'var(--color-red-status)';
        return null;
    }
}

function processJsonGeneration() {
    const jsonPre = document.getElementById('json-output');
    const codeBlock = document.querySelector('.code-block-wrapper');
    const copyBtn = document.getElementById('copy-json-btn');

    if (!currentDeck) {
        alert('Please generate a deck first before creating JSON.');
        return;
    }
    const jsonString = formatDeckAsJson(currentDeck, currentDeckTheme);
    if (jsonString) {
        jsonPre.textContent = jsonString;
        codeBlock.style.display = 'block';
        copyBtn.textContent = '🗐';
    }
}

async function initialize() {
    Object.entries(DECK_ARCHETYPES).forEach(([name, data], index) => {
        const input = document.createElement('input');
        input.type = 'radio'; input.id = `archetype-${name}`; input.name = 'archetype'; input.value = name;
        if (index === 0) input.checked = true;
        const label = document.createElement('label');
        label.htmlFor = `archetype-${name}`; label.textContent = name; label.title = data.description;
        archetypeOptionsDiv.appendChild(input);
        archetypeOptionsDiv.appendChild(label);
    });

    const mainContainer = document.querySelector('.main-container');
    const jsonSection = document.createElement('div');
    jsonSection.id = 'json-generator-section';
    jsonSection.style.display = 'none';
    
    const jsonButton = document.createElement('button');
    jsonButton.id = 'generate-json-btn';
    jsonButton.className = 'action-button';
    jsonButton.textContent = 'Generate Deck JSON';
    
    const codeBlock = document.createElement('div');
    codeBlock.className = 'code-block-wrapper';
    codeBlock.style.display = 'none';
    
    const header = document.createElement('div');
    header.className = 'code-header';
    const title = document.createElement('span');
    title.textContent = 'Deck JSON Output';
    const copyBtn = document.createElement('button');
    copyBtn.id = 'copy-json-btn';
    copyBtn.title = 'Copy code';
    copyBtn.textContent = '🗐';
    header.appendChild(title);
    header.appendChild(copyBtn);
    
    const body = document.createElement('div');
    body.className = 'code-body';
    const jsonPre = document.createElement('pre');
    jsonPre.id = 'json-output';
    body.appendChild(jsonPre);

    const warningDiv = document.createElement('div');
    warningDiv.id = 'json-warning';
    warningDiv.innerHTML = `⚠️ <strong>WARNING</strong> ⚠️ This JSON format is exclusively valid for the deckProfiles.json file and is intended solely for coding purposes. Do not use this format for other applications or files, as it may not be compatible with other systems or use cases.`;

    codeBlock.appendChild(header);
    codeBlock.appendChild(body);
    codeBlock.appendChild(warningDiv);
    
    jsonSection.appendChild(jsonButton);
    jsonSection.appendChild(codeBlock);
    mainContainer.appendChild(jsonSection);

    // --- Create and append Passkey Modal ---
    const modalOverlay = document.createElement('div');
    modalOverlay.className = 'modal-overlay';
    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    modalContent.innerHTML = `
        <h2>⚠️ ADMIN ACCESS REQUIRED ⚠️</h2>
        <p>Please enter admin passkey to continue.</p>
        <div class="passkey-container">
            <input type="password" class="passkey-input" maxlength="1" autocomplete="off">
            <input type="password" class="passkey-input" maxlength="1" autocomplete="off">
            <input type="password" class="passkey-input" maxlength="1" autocomplete="off">
            <input type="password" class="passkey-input" maxlength="1" autocomplete="off">
        </div>
        <p id="passkey-error"></p>
    `;
    modalOverlay.appendChild(modalContent);
    document.body.appendChild(modalOverlay);

    // --- Passkey Modal Logic ---
    const PASSKEY = 'T419';
    const MAX_PASSKEY_ATTEMPTS = 3;
    let passkeyAttempts = 0;
    const passkeyInputs = modalContent.querySelectorAll('.passkey-input');
    const passkeyError = document.getElementById('passkey-error');

    jsonButton.addEventListener('click', () => {
        if (!currentDeck) {
            alert('Please generate a deck first.');
            return;
        }
        passkeyAttempts = 0;
        passkeyError.style.visibility = 'hidden';
        passkeyInputs.forEach(input => input.value = '');
        modalOverlay.style.display = 'flex';
        passkeyInputs[0].focus();
    });

    modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) modalOverlay.style.display = 'none';
    });

    passkeyInputs.forEach((input, index) => {
        input.addEventListener('input', (e) => {
            input.value = e.target.value.toUpperCase();
            if (input.value && index < passkeyInputs.length - 1) passkeyInputs[index + 1].focus();
            if (Array.from(passkeyInputs).every(i => i.value)) verifyPasskey();
        });
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Backspace' && !input.value && index > 0) passkeyInputs[index - 1].focus();
        });
        input.addEventListener('paste', (e) => {
            e.preventDefault();
            const pasteData = e.clipboardData.getData('text').toUpperCase();
            for (let i = 0; i < pasteData.length && (index + i) < passkeyInputs.length; i++) {
                passkeyInputs[index + i].value = pasteData[i];
            }
            if (Array.from(passkeyInputs).every(i => i.value)) verifyPasskey();
        });
    });

    function verifyPasskey() {
        const enteredPasskey = Array.from(passkeyInputs).map(i => i.value).join('');
        if (enteredPasskey === PASSKEY) {
            modalOverlay.style.display = 'none';
            processJsonGeneration();
        } else {
            passkeyAttempts++;
            const attemptsLeft = MAX_PASSKEY_ATTEMPTS - passkeyAttempts;
            passkeyInputs.forEach(input => input.value = '');
            passkeyError.style.visibility = 'visible';
            if (attemptsLeft <= 0) {
                passkeyError.textContent = 'Too many failed attempts. Reloading...';
                setTimeout(() => { window.location.reload(); }, 1500);
            } else {
                passkeyError.textContent = `Incorrect Passkey. ${attemptsLeft} attempt(s) remaining.`;
                passkeyInputs[0].focus();
            }
        }
    }
    
    copyBtn.addEventListener('click', () => {
        navigator.clipboard.writeText(jsonPre.textContent).then(() => {
            copyBtn.textContent = '✓ Copied!';
            setTimeout(() => { copyBtn.textContent = '🗐'; }, 2000);
        }, (err) => {
            console.error('Failed to copy text: ', err);
            alert('Failed to copy text.');
        });
    });

    const cardDataUrl = 'https://raw.githubusercontent.com/nerdrealm/mystik_builder/main/cardProfiles.json';
    all_cards = await loadCardsFromJson(cardDataUrl);
    if (all_cards) {
        companion_map = getCompanionMap(all_cards);
        statusDiv.textContent = `Ready to build. Please select a theme and archetype.`;
        statusDiv.style.color = 'var(--color-green-status)';
        generateBtn.disabled = false;
    } else {
        generateBtn.disabled = true;
    }

    generateBtn.addEventListener('click', () => {
        const rawThemeInput = themeInput.value.trim();
        if (!rawThemeInput) { alert("Please enter a Deck Type Theme."); return; }
        
        const deckTheme = rawThemeInput.replace(/[,\s]+/g, '/').split('/').map(p => p.trim()).filter(p => p).map(p => p.charAt(0).toUpperCase() + p.slice(1).toLowerCase()).join('/');
        const archetype = document.querySelector('input[name="archetype"]:checked').value;
        
        statusDiv.textContent = `Building a(n) ${archetype} deck with the ${deckTheme} theme...`;
        statusDiv.style.color = 'var(--color-cyan-status)';
        cautionDiv.style.display = 'none';
        
        jsonSection.style.display = 'none';
        codeBlock.style.display = 'none';
        
        setTimeout(() => {
            try {
                const deck = buildStrategicDeck(deckTheme, archetype);
                currentDeck = deck;
                currentDeckTheme = deckTheme;
                displayDeck(deck, deckTheme, archetype);
                statusDiv.textContent = "Deck generated successfully!";
                statusDiv.style.color = 'var(--color-green-status)';
                cautionDiv.style.display = 'block';
                jsonSection.style.display = 'flex';
            } catch (e) {
                statusDiv.textContent = "An error occurred during deck generation. See console for details.";
                statusDiv.style.color = 'var(--color-red-status)';
                console.error(e);
            }
        }, 50);
    });

    themeInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !generateBtn.disabled) {
            event.preventDefault(); 
            generateBtn.click();    
        }
    });
}

initialize();

});
</script>

</body>
</html>
