<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystik Creatures Deck Builder</title>
    <style>
        :root {
            --bg-color: #1e1e1e; /* Charcoal Black */
            --container-bg: #2d2d2d; /* Slightly Lighter Charcoal */
            --input-bg: #3c3c3c;
            --text-color: #FFD700; /* Golden Yellow */
            --text-light: #dcdcdc;
            --border-color: #FFD700; /* Golden Yellow */
            --btn-color: #FFD700; /* Golden Yellow */
            --btn-text-color: #1e1e1e; /* Dark text on yellow button */
            --btn-hover-color: #ffeb99; /* Lighter yellow for hover */
            
            /* Status Colors */
            --color-yellow-status: #f1c40f;
            --color-red-status: #e74c3c;
            --color-green-status: #2ecc71;
            --color-cyan-status: #1abc9c;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .main-container {
            width: 100%;
            max-width: 1200px;
            background-color: var(--container-bg);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.25);
        }

        header {
            display: flex; 
            align-items: center; 
            justify-content: center; 
            margin-bottom: 25px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 20px;
        }

        header img {
            max-width: 200px; 
            margin-right: 25px; 
        }

        header h1 {
            color: var(--text-color);
            margin: 0;
            font-size: 2.5em; 
            text-shadow: 0 0 5px var(--text-color);
        }

        #status {
            text-align: center;
            padding: 10px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
            color: var(--color-yellow-status);
            border: 1px solid;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background-color: var(--bg-color);
            border-radius: 8px;
        }
        
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            margin-bottom: 5px; 
            font-weight: bold;
            color: var(--text-color);
        }

        .theme-hint {
            font-size: 0.85em;
            color: #bbbbbb;
            margin-top: 0;
            margin-bottom: 10px;
            font-style: italic;
        }

        .control-group input[type="text"] {
            padding: 12px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-light);
            font-size: 1em;
        }
        
        .archetype-options {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .archetype-options label {
            cursor: pointer;
            padding: 10px 15px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            transition: all 0.2s ease-in-out;
        }
        
        .archetype-options input[type="radio"] {
            display: none;
        }
        
        .archetype-options input[type="radio"]:checked + label {
            background-color: var(--btn-color);
            color: var(--btn-text-color);
            font-weight: bold;
            box-shadow: 0 0 10px var(--btn-color);
        }

        .action-button {
            grid-column: 1 / -1;
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            color: var(--btn-text-color);
            background-color: var(--btn-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .action-button:hover {
            background-color: var(--btn-hover-color);
        }
        
        .action-button:disabled {
            background-color: #555;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
            border-color: #555;
        }

        #output {
            display: none; 
            padding-bottom: 20px;
        }
        
        #caution-message {
            text-align: center;
            padding: 15px;
            background-color: var(--bg-color);
            border: 2px solid var(--color-yellow-status);
            border-radius: 8px;
            margin-bottom: 20px;
        }

        #caution-message h3 {
            margin: 0 0 10px 0;
            font-weight: bold;
            text-transform: uppercase;
            color: var(--color-yellow-status);
        }

        #caution-message p {
            margin: 0;
            line-height: 1.5;
            color: var(--text-light);
        }
        
        #caution-message p:first-of-type {
            margin-bottom: 10px;
        }

        #deck-summary {
            text-align: center;
            padding: 15px;
            background-color: var(--bg-color);
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        #deck-summary h2 {
            margin: 0 0 10px 0;
            color: var(--text-color);
        }
        
        #deck-list-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .card-list {
            background-color: var(--bg-color);
            padding: 15px;
            border-radius: 8px;
        }
        
        .card-list h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--border-color);
            color: var(--text-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        
        .card-list ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        
        .card-list li {
            padding: 5px 0;
            border-bottom: 1px solid var(--input-bg);
        }

        .card-list li:last-child {
            border-bottom: none;
        }

        /* Styles for dynamic Creature sort buttons */
        .sort-controls {
            display: inline-flex;
            gap: 8px;
            margin-left: 15px;
            vertical-align: middle;
        }
        .sort-btn {
            background-color: var(--input-bg);
            color: var(--text-light);
            border: 1px solid var(--border-color);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            cursor: pointer;
        }
        .sort-btn:hover {
            background-color: var(--border-color);
            color: var(--btn-text-color);
        }

        /* Styles for new JSON Generator Section */
        #json-generator-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: center; /* Center the button */
            gap: 20px; /* Space between button and code block */
        }
        
        /* New AI-style code block */
        .code-block-wrapper {
            width: 100%;
            max-width: 800px;
            border: 1px solid var(--input-bg);
            border-radius: 8px;
            background-color: #111;
            overflow: hidden; /* Ensures children conform to border-radius */
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--input-bg);
            padding: 8px 15px;
            color: var(--text-light);
            font-size: 0.9em;
        }

        #copy-json-btn {
            background: none;
            border: 1px solid #777;
            color: #ccc;
            padding: 4px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }
        #copy-json-btn:hover {
            background-color: #555;
            color: white;
            border-color: #999;
        }

        .code-body {
            padding: 15px;
        }

        #json-output {
            background: none;
            color: #dcdcdc;
            padding: 0;
            margin: 0;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            border: none;
        }
        
        #json-warning {
            padding: 12px 15px;
            background-color: rgba(241, 196, 15, 0.1); /* Yellow transparent bg */
            border-top: 1px solid var(--color-yellow-status);
            color: #f3dca1;
            font-size: 0.9em;
            line-height: 1.4;
        }
        #json-warning strong {
            color: var(--color-yellow-status);
        }

    </style>
</head>
<body>

    <div class="main-container">
        <header>
            <img src="https://raw.githubusercontent.com/nerdrealm/mystik_builder/main/MystikLogo-PNG.png" 
                 alt="Mystik Creatures Logo" 
                 onerror="this.style.display='none'; this.nextSibling.style.display='block';">
            <p style="display:none; color: var(--color-red-status);">Logo failed to load. Make sure 'MystikLogo-PNG.png' exists in your public GitHub repository.</p>
            <h1>Mystik Creatures Deck Builder</h1>
        </header>

        <div id="status">Loading card data... Please wait.</div>

        <div class="controls">
            <div class="control-group">
                <label for="deckTheme">Deck Type Theme</label>
                <p class="theme-hint">Types: Fire, Water, Dark, Thunder, Earth, Wind, Forest, Light, or Blank. <br>Combine two or more with a slash, space, or comma.</p>
                <input type="text" id="deckTheme" placeholder="Enter a theme here...">
            </div>

            <div class="control-group">
                <label>Deck Archetype</label>
                <div id="archetype-options" class="archetype-options">
                    <!-- Options will be populated by JS -->
                </div>
            </div>

            <button id="generate-btn" class="action-button" disabled>Generate Deck</button>
        </div>

        <div id="caution-message" style="display: none;">
            <h3>CAUTION</h3>
            <p>Some cards in this deck may not fit your build or strategy, and others may not meet official deck-building rules.</p>
            <p>Always tailor your deck around your core Creatures, and be sure to follow all level, rarity, and card limits.</p>
        </div>

        <div id="output">
            <div id="deck-summary">
                <h2 id="deck-title"></h2>
                <p id="deck-stats"></p>
            </div>
            <div id="deck-list-container">
                <div class="card-list">
                    <h3 id="creatures-title">Creatures</h3>
                    <ul id="creatures-list"></ul>
                </div>
                <div class="card-list">
                    <h3 id="power-title">Power</h3>
                    <ul id="power-list"></ul>
                </div>
                <div class="card-list">
                    <h3 id="secrets-title">Secrets</h3>
                    <ul id="secrets-list"></ul>
                </div>
            </div>
        </div>
        <!-- JSON generator will be inserted here by JS -->
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

// --- CONFIGURATION & DECK RULES ---
const DECK_RULES = {
    "deck_size": 60,
    "creature_card_limits": { "Common": 4, "Uncommon": 3, "Rare": 2, "UltraRare": 2 },
    "level_10_limits": { "total": 4 },
    "power_card_limits": { "powerValue_1": Infinity, "powerValue_2": 5 },
    "secret_card_limits": { "Common": 3, "Uncommon": 2, "Rare": 1 }
};

const DECK_ARCHETYPES = {
    "Balanced": { "creatures": 0.40, "secrets": 0.35, "power": 0.25, "description": "A well-rounded deck" },
    "Aggro": { "creatures": 0.50, "secrets": 0.25, "power": 0.25, "description": "Creature-heavy and aggressive" },
    "Control": { "creatures": 0.30, "secrets": 0.45, "power": 0.25, "description": "Secret-heavy and disruptive" },
    "Energy": { "creatures": 0.35, "secrets": 0.30, "power": 0.35, "description": "Power-heavy for big plays" }
};

const ARCHETYPE_COLORS = {
    "Balanced": "var(--color-green-status)",
    "Aggro": "var(--color-red-status)",
    "Control": "var(--color-yellow-status)",
    "Energy": "var(--color-cyan-status)"
};

const TERRAIN_TYPE_COMPATIBILITY = {
    "Ancient Forests of Rehm": ["Forest"], "Aquatic Paradise": ["Water", "Forest"], "Dark Shadows": ["Dark"],
    "Huricanes off Jimbora": ["Thunder"], "Infernal Pits of Crom": ["Fire"], "Lights of Nura": ["Light"],
    "Mountains of Eurotha": ["Earth"], "Oceans of Nimbitu": ["Water"], "Pixie Forest": ["Forest"],
    "Poisonous Swamp": ["Earth", "Dark"], "Rough Seas": ["Water"], "Sacred Grounds": ["Thunder", "Light"],
    "Sandstorm": ["Earth"], "Scorched Fields": ["Wind", "Fire"], "Shadow Plains": ["Dark"],
    "Southern Winds of Us'ah": ["Wind"], "Star of Septeptus": ["Light"], "Stomy Skies": ["Thunder"],
    "Torn Wastelands": ["All"], "Volcanoes of Westu'ra": ["Fire"], "Winds off the Coast": ["Wind"]
};

// --- NEW: BOSS & COMPANION ENFORCEMENT MAP ---
const BOSS_COMPANION_MAP = {
    "Arcana Temptress": ["Arcana Apprentice"],
    "Dracoleón": ["Nemean Lion"],
    "Hydra": ["Nereus"],
    "Infinity Mage": ["Infinity Apprentice"],
    "Phoenix, the Rising": ["Phoenic"],
    "Serpopard": ["Anuket"],
    "Werelephant": ["Pebblephant"],
    "Zombified Dragon": ["Dragon Tamer"],
    "Divine Beast Panterus": ["Winged Beast U'ru", "Winged Beast Wai'ku", "Winged Beast Ra'zu"]
};


// --- GLOBAL VARIABLES & DOM ELEMENTS ---
let all_cards = [];
let companion_map = {}; // For synergy scoring
let currentDeck = null;
let currentDeckTheme = '';

const statusDiv = document.getElementById('status');
const generateBtn = document.getElementById('generate-btn');
const themeInput = document.getElementById('deckTheme');
const archetypeOptionsDiv = document.getElementById('archetype-options');
const outputDiv = document.getElementById('output');
const deckTitleH2 = document.getElementById('deck-title');
const deckStatsP = document.getElementById('deck-stats');
const creaturesListUl = document.getElementById('creatures-list');
const powerListUl = document.getElementById('power-list');
const secretsListUl = document.getElementById('secrets-list');
const creaturesTitleH3 = document.getElementById('creatures-title');
const powerTitleH3 = document.getElementById('power-title');
const secretsTitleH3 = document.getElementById('secrets-title');
const cautionDiv = document.getElementById('caution-message');

const defaultdict = (defaultValueFactory) => new Proxy({}, {
    get: (target, name) => name in target ? target[name] : (target[name] = defaultValueFactory())
});

// --- DATA LOADING & INITIALIZATION ---
async function loadCardsFromJson(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        const unique_cards = [];
        const seen = new Set();
        for (const card of data) {
            if (!card.id) {
                console.warn(`Card "${card.name}" is missing an 'id' field, which is required for JSON export.`);
            }
            card.script_uuid = crypto.randomUUID();
            const identifier = `${card.name}|${card.collectionNumber}`;
            if (!seen.has(identifier)) {
                unique_cards.push(card);
                seen.add(identifier);
            }
        }
        return unique_cards;
    } catch (e) {
        statusDiv.innerHTML = `<strong>ERROR:</strong> Failed to fetch card data.`;
        statusDiv.style.color = 'var(--color-red-status)';
        console.error("Error loading card data:", e);
        return null;
    }
}

// --- SYNERGY & HELPER FUNCTIONS ---
function getCompanionMap(cards) {
    const newCompanionMap = defaultdict(() => ({ creatures: [], secrets: [] }));
    for (const card of cards) {
        if (card.supertype !== 'Creature') continue;
        for (const ability of card.abilities || []) {
            for (const prereq of ability.prerequisites || []) {
                if (prereq.type === 'SacrificeSpecificCreature') newCompanionMap[card.name].creatures.push(prereq.creatureName);
                else if (prereq.type === 'PlaySpecificCard') newCompanionMap[card.name].secrets.push(prereq.cardName);
                // --- NEW: Add HasCreatureInPlay for synergy scoring ---
                else if (prereq.type === 'HasCreatureInPlay') newCompanionMap[card.name].creatures.push(prereq.creatureName);
            }
        }
    }
    return newCompanionMap;
}

function analyzePowerRequirements(creatures) {
    const powerNeeds = defaultdict(() => 0);
    let totalPowerCost = 0;
    for (const creature of creatures) {
        for (const attack of creature.attacks || []) {
            for (const cost of attack.cost || []) {
                powerNeeds[cost.PowerType] += cost.count;
                totalPowerCost += cost.count;
            }
        }
    }
    const avgPowerPerCreature = creatures.length > 0 ? totalPowerCost / creatures.length : 2;
    const minPowerCards = Math.max(12, Math.floor(avgPowerPerCreature * creatures.length * 0.3));
    return [powerNeeds, minPowerCards];
}

const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

function scoreCreatureSynergyBlank(card) {
    let score = randInt(0, 20);
    if (Object.values(companion_map).some(v => v.creatures.includes(card.name))) score += 50;
    if (card.name in companion_map) score += 50;
    if (card.rarity === 'Rare') score += 20;
    if (card.rarity === 'UltraRare') score += 40;
    if ((card.level || 0) >= 7) score += 15;
    return score;
}

function scoreCreatureSynergy(card, deckTheme) {
    let score = randInt(0, 20);
    const cardTypes = card.types || [];
    const themeTypes = deckTheme.split('/');
    if (!themeTypes.some(t => cardTypes.includes(t))) return -1;
    score += 50;
    if (themeTypes.length > 1 && themeTypes.every(t => cardTypes.includes(t))) score += 40;
    const themeMechanics = { "Dark": ["Disruption", "Control"], "Fire": ["Damage", "StatBoost"], "Water": ["Healing", "Control", "CardManipulation"], "Earth": ["Defense", "StatBoost", "Healing"], "Wind": ["Control", "Utility", "CardManipulation"], "Thunder": ["Debuff", "Damage"], "Forest": ["Healing", "StatBoost", "Debuff"], "Light": ["Healing", "Utility", "CardManipulation", "Buff"] };
    const allEffects = [...(card.abilities || []).flatMap(a => a.structuredEffects || []), ...(card.attacks || []).flatMap(a => a.structuredEffects || [])];
    for (const effect of allEffects) {
        const category = effect.category;
        for (const theme of themeTypes) {
            if ((themeMechanics[theme] || []).includes(category)) score += 25;
        }
    }
    if (Object.values(companion_map).some(v => v.creatures.includes(card.name))) score += 30;
    if (card.name in companion_map) score += 30;
    if (card.rarity === 'Rare') score += 15;
    if (card.rarity === 'UltraRare') score += 25;
    if ((card.level || 0) >= 7) score += 10;
    return score;
}

// --- NEW: REVISED scoreSecretSynergy to match Python logic ---
function scoreSecretSynergy(card, deckTheme, creaturesInDeck) {
    const cardName = card.name || '';
    
    // Rule: Never choose "Elemental Break"
    if (cardName === "Elemental Break") {
        return -1;
    }

    // Highest priority: check for boss-companion synergy
    for (const bossName in companion_map) {
        if ((companion_map[bossName].secrets || []).includes(cardName)) {
            const isBossPresent = creaturesInDeck.some(c => c.name === bossName);
            return isBossPresent ? 1000 : -1;
        }
    }
            
    let score = randInt(0, 10);
    const themeTypes = deckTheme.split('/');

    // Part 1: Handle Type Modification as a primary filter
    let isInvalidTypeMod = false;
    for (const ability of card.abilities || []) {
        for (const effect of ability.structuredEffects || []) {
            if (effect.category === 'TypeModification') {
                const addedType = effect.addType;
                
                // NEW RULE: Type modification cards are invalid for single-type decks.
                if (themeTypes.length === 1 && deckTheme !== 'Blank') {
                    isInvalidTypeMod = true;
                    break;
                }

                // For cards like Elemental Infusion where addType is not specified.
                if (!addedType) {
                    score += 100; // Valid for multi-type or blank decks.
                    continue; // Check other effects on the card.
                }
                
                // Rule for multi-type decks
                if (themeTypes.length > 1) {
                    if (themeTypes.includes(addedType)) {
                        score += 150; // Highly synergistic
                    } else {
                        isInvalidTypeMod = true; // Adds an unwanted 3rd type
                        break;
                    }
                } 
                // Rule for Blank decks
                else if (deckTheme === 'Blank') {
                    const creatureTypesInDeck = new Set(creaturesInDeck.flatMap(c => c.types || []));
                    if (creatureTypesInDeck.has(addedType)) {
                        score += 75; // Good internal synergy
                    } else {
                        isInvalidTypeMod = true; // Introduces an unsupported type
                        break;
                    }
                }
            }
        }
        if (isInvalidTypeMod) break;
    }
    
    if (isInvalidTypeMod) {
        return -1; // This card is not suitable for the deck's theme
    }

    // Part 2: Handle Terrain Cards
    if ((card.subtypes || [null])[0] === 'Terrain') {
        if (deckTheme === 'Blank') return -1; // No terrains in Blank decks

        const validTypes = TERRAIN_TYPE_COMPATIBILITY[cardName] || [];
        let terrainMatchesTheme = false;
        
        if (validTypes.includes("All")) {
            terrainMatchesTheme = true;
            score += 60;
        } else {
            for (const themeType of themeTypes) {
                if (validTypes.includes(themeType)) {
                    terrainMatchesTheme = true;
                    score += 80;
                    break;
                }
            }
        }
        
        if (!terrainMatchesTheme) {
            return -1;
        }
            
    // Part 3: Handle other effects
    } else {
        const effectText = (card.effectText || '').toLowerCase();
        for (const theme of themeTypes) {
            if (effectText.includes(theme.toLowerCase())) {
                score += 25;
            }
        }
    }
    
    return score;
}

// --- CORE DECK BUILDING FUNCTION (WITH NEW LOGIC) ---
function buildStrategicDeck(selectedTypes, archetype_name) {
    const deck = { "Creatures": [], "Power": [], "Secrets": [] };
    const archetype = DECK_ARCHETYPES[archetype_name];
    const is_blank_deck = (selectedTypes === 'Blank');

    let targetCreatures = Math.floor(DECK_RULES.deck_size * archetype.creatures);
    let targetSecrets = Math.floor(DECK_RULES.deck_size * archetype.secrets);
    let targetPower = Math.floor(DECK_RULES.deck_size * archetype.power);
    
    const all_creatures = all_cards.filter(c => c.supertype === 'Creature');

    // --- 2. CREATURE SELECTION (REVISED) ---
    const creatureSelectionFn = is_blank_deck ? scoreCreatureSynergyBlank : (c) => scoreCreatureSynergy(c, selectedTypes);
    const available_creatures = all_creatures.filter(c => is_blank_deck || (c.types || []).some(t => selectedTypes.split('/').includes(t)));
    const scored_creatures = available_creatures.map(c => [c, creatureSelectionFn(c)]).sort((a, b) => b[1] - a[1]);
    
    let scored_low = scored_creatures.filter(([c, s]) => (c.level || 0) >= 1 && (c.level || 0) <= 3);
    let scored_mid = scored_creatures.filter(([c, s]) => (c.level || 0) >= 4 && (c.level || 0) <= 6);
    let scored_high = scored_creatures.filter(([c, s]) => (c.level || 0) >= 7);
    
    const creatureCounts = defaultdict(() => 0);
    let level_10_count = 0;
    let panterus_priority_set = false; // Flag for Panterus logic

    const prioritizeInPool = (pool, priorityNames) => {
        const priorityItems = pool.filter(([card, score]) => priorityNames.includes(card.name));
        const otherItems = pool.filter(([card, score]) => !priorityNames.includes(card.name));
        return [...priorityItems, ...otherItems];
    };

    while (deck.Creatures.length < targetCreatures) {
        const num_low = deck.Creatures.filter(c => (c.level || 0) >= 1 && (c.level || 0) <= 3).length;
        const num_mid = deck.Creatures.filter(c => (c.level || 0) >= 4 && (c.level || 0) <= 6).length;
        
        let selectionPool = [];
        if (num_low < Math.floor(targetCreatures * 0.45) && scored_low.length > 0) selectionPool.push(...scored_low.slice(0, 10));
        if (num_mid < Math.floor(targetCreatures * 0.35) && scored_mid.length > 0) selectionPool.push(...scored_mid.slice(0, 7));
        if (scored_high.length > 0) selectionPool.push(...scored_high.slice(0, 5));
        
        if (selectionPool.length === 0) {
            selectionPool.push(...scored_low.slice(0, 10), ...scored_mid.slice(0, 7), ...scored_high.slice(0, 5));
            if (selectionPool.length === 0) break;
        }

        const uniquePool = [...new Map(selectionPool.map(item => [item[0].script_uuid, item])).values()];
        if (uniquePool.length === 0) break;
        
        const [card_to_add, _] = uniquePool[Math.floor(Math.random() * uniquePool.length)];
        const { name: card_name, rarity: card_rarity, level: card_level = 0 } = card_to_add;
        
        if ((card_level === 10 && level_10_count >= DECK_RULES.level_10_limits.total) || (creatureCounts[card_name] >= (DECK_RULES.creature_card_limits[card_rarity] || 1))) {
            scored_low = scored_low.filter(([c,s]) => c.script_uuid !== card_to_add.script_uuid);
            scored_mid = scored_mid.filter(([c,s]) => c.script_uuid !== card_to_add.script_uuid);
            scored_high = scored_high.filter(([c,s]) => c.script_uuid !== card_to_add.script_uuid);
            continue;
        }

        deck.Creatures.push(card_to_add);
        creatureCounts[card_name]++;
        if (card_level === 10) level_10_count++;
        
        // --- NEW: COMPANION ENFORCEMENT & SPECIAL CASE LOGIC ---
        if (card_name === "Divine Beast Panterus" && !panterus_priority_set) {
            const wingedBeastNames = BOSS_COMPANION_MAP["Divine Beast Panterus"];
            scored_low = prioritizeInPool(scored_low, wingedBeastNames);
            scored_mid = prioritizeInPool(scored_mid, wingedBeastNames);
            scored_high = prioritizeInPool(scored_high, wingedBeastNames);
            panterus_priority_set = true;
        }
        
        if (card_name in BOSS_COMPANION_MAP) {
            for (const comp_name of BOSS_COMPANION_MAP[card_name]) {
                if (deck.Creatures.length >= targetCreatures) break;

                const comp_card = all_creatures.find(c => c.name === comp_name);
                if (comp_card) {
                    const { rarity: cc_rarity, level: cc_level = 0 } = comp_card;
                    const canAdd = creatureCounts[comp_name] < (DECK_RULES.creature_card_limits[cc_rarity] || 1) &&
                                   !(cc_level === 10 && level_10_count >= DECK_RULES.level_10_limits.total);
                    
                    if (canAdd) {
                        deck.Creatures.push(comp_card);
                        creatureCounts[comp_name]++;
                        if (cc_level === 10) level_10_count++;
                    }
                }
            }
        }
    }

    // --- 3. POWER CARD SELECTION & ADJUSTMENT (No changes needed here) ---
    const [power_needs, min_power_needed] = analyzePowerRequirements(deck.Creatures);
    if (targetPower < min_power_needed) {
        const power_deficit = min_power_needed - targetPower;
        targetPower = min_power_needed;
        const creature_ratio = archetype.creatures / (archetype.creatures + archetype.secrets) || 0.5;
        targetCreatures = Math.max(15, targetCreatures - Math.round(power_deficit * creature_ratio));
        targetSecrets = Math.max(8, targetSecrets - (power_deficit - Math.round(power_deficit * creature_ratio)));
        while (deck.Creatures.length > targetCreatures) deck.Creatures.pop();
    }
    
    const powerCardsByType = defaultdict(() => []);
    all_cards.filter(c => c.supertype === 'Power').forEach(c => powerCardsByType[c.powerType].push(c));
    
    const powerDistribution = defaultdict(() => 0);
    if (is_blank_deck) {
        const creature_type_counts = defaultdict(() => 0);
        deck.Creatures.forEach(c => (c.types || []).forEach(type => creature_type_counts[type]++));
        const min_blank_power = Math.max(Math.floor(targetPower / 2), 3);
        // Include power needs from attacks
        for (const type in power_needs) {
            powerDistribution[type] += power_needs[type];
        }
        for (const type in creature_type_counts) {
            powerDistribution[type] = Math.max(powerDistribution[type], Math.max(1, Math.min(creature_type_counts[type], 2)));
        }
        const used_power = Object.values(powerDistribution).reduce((a, b) => a + b, 0);
        const remaining_slots = targetPower - used_power;
        const blank_allocation = Math.max(min_blank_power, remaining_slots);
        powerDistribution['Blank'] = Math.min(blank_allocation, 12);
        let total_allocated = Object.values(powerDistribution).reduce((a, b) => a + b, 0);
        if (total_allocated > targetPower) {
            const excess = total_allocated - targetPower;
            powerDistribution['Blank'] = Math.max(min_blank_power, powerDistribution['Blank'] - excess);
        }
    } else {
        Object.assign(powerDistribution, power_needs);
        const themeTypes = selectedTypes.split('/');
        themeTypes.forEach(themeType => {
            if (!(themeType in powerDistribution)) powerDistribution[themeType] = 0;
            const min_for_theme = Math.max(2, Math.floor(targetPower / (themeTypes.length * 3) || 1));
            powerDistribution[themeType] = Math.max(powerDistribution[themeType], min_for_theme);
        });
    }

    let double_power_count = 0;
    const power_efficiency_threshold = 2.5;

    while (deck.Power.length < targetPower) {
        let most_needed_type;
        const needed_types = Object.entries(powerDistribution).filter(([k, v]) => v > 0);
        
        if (needed_types.length === 0) {
            most_needed_type = is_blank_deck ? 'Blank' : selectedTypes.split('/')[0];
        } else {
            const population = needed_types.flatMap(([type, weight]) => Array(Math.ceil(weight)).fill(type));
            most_needed_type = population[Math.floor(Math.random() * population.length)];
        }

        const current_need = powerDistribution[most_needed_type] || 0;
        const remaining_slots = targetPower - deck.Power.length;
        const should_use_double = (
            double_power_count < DECK_RULES.power_card_limits.powerValue_2 &&
            current_need >= power_efficiency_threshold &&
            remaining_slots >= 2 &&
            current_need >= remaining_slots * 0.4 &&
            powerCardsByType[most_needed_type].some(c => (c.powerValue || 1) === 2)
        );

        if (should_use_double) {
            const card_to_add = powerCardsByType[most_needed_type].find(c => (c.powerValue || 1) === 2);
            deck.Power.push(card_to_add);
            powerDistribution[most_needed_type] = Math.max(0, powerDistribution[most_needed_type] - 2);
            double_power_count++;
        } else {
            let available_single = powerCardsByType[most_needed_type].filter(c => (c.powerValue || 1) === 1);
            let fallback_type = most_needed_type;
            if (available_single.length === 0) {
                available_single = powerCardsByType['Blank'].filter(c => (c.powerValue || 1) === 1);
                fallback_type = 'Blank';
            }
            if (available_single.length === 0) break;
            
            const card_to_add = available_single[0];
            deck.Power.push(card_to_add);
            powerDistribution[fallback_type] = Math.max(0, powerDistribution[fallback_type] - 1);

            if (is_blank_deck && fallback_type === 'Blank') {
                const blank_value_count = deck.Power.filter(p => p.powerType === 'Blank').reduce((sum, p) => sum + (p.powerValue || 1), 0);
                if (blank_value_count >= 12) powerDistribution['Blank'] = 0;
            }
        }
    }
    
    // --- 4. SECRET CARD SELECTION (Now uses updated scoring) ---
    const available_secrets = all_cards.filter(c => c.supertype === 'Secret');
    let scored_secrets = [];
    for (const secret of available_secrets) {
        const synergy_score = scoreSecretSynergy(secret, selectedTypes, deck.Creatures);
        if (synergy_score >= 0) {
            scored_secrets.push([secret, synergy_score]);
        }
    }
    scored_secrets.sort((a, b) => b[1] - a[1]);

    const companionSecrets = scored_secrets.filter(([card, score]) => score >= 1000);
    const terrainSecrets = scored_secrets.filter(([card, score]) => (card.subtypes || [null])[0] === 'Terrain' && score < 1000);
    const generalSecrets = scored_secrets.filter(([card, score]) => (card.subtypes || [null])[0] !== 'Terrain' && score < 1000);

    const secret_counts = defaultdict(() => 0);
    const terrain_counts = defaultdict(() => 0);

    while (deck.Secrets.length < targetSecrets) {
        const currentTerrainCount = deck.Secrets.filter(c => (c.subtypes || [null])[0] === 'Terrain').length;
        
        let selectionPool = [];
        selectionPool.push(...companionSecrets);
        if (currentTerrainCount < 3) {
            selectionPool.push(...terrainSecrets.slice(0, 5));
        }
        selectionPool.push(...generalSecrets.slice(0, 10));

        let validCandidates = [];
        for (const [card, score] of selectionPool) {
            const card_name = card.name;
            const card_rarity = card.rarity;
            const is_terrain = (card.subtypes || [null])[0] === 'Terrain';

            if (secret_counts[card_name] >= (DECK_RULES.secret_card_limits[card_rarity] || 1)) continue;
            if (is_terrain && (currentTerrainCount >= 4 || (!(card_name in terrain_counts) && Object.keys(terrain_counts).length >= 3))) continue;
            
            validCandidates.push([card, score]);
        }

        if (validCandidates.length === 0) break; 

        const [card_to_add, _] = validCandidates[Math.floor(Math.random() * validCandidates.length)];

        deck.Secrets.push(card_to_add);
        secret_counts[card_to_add.name]++;
        if ((card_to_add.subtypes || [null])[0] === 'Terrain') {
            terrain_counts[card_to_add.name]++;
        }
    }
        
    // --- 5. FINAL ADJUSTMENT ---
    while (deck.Creatures.length + deck.Power.length + deck.Secrets.length > 60) {
        if (deck.Power.length > targetPower) deck.Power.pop();
        else if (deck.Secrets.length > targetSecrets) deck.Secrets.pop();
        else deck.Creatures.pop();
    }
    while (deck.Creatures.length + deck.Power.length + deck.Secrets.length < 60) {
        let power_card_to_add = (powerCardsByType['Blank'] || [null])[0];
        if (!is_blank_deck) {
            const main_theme = selectedTypes.split('/')[0];
            const themed_power_card = (powerCardsByType[main_theme] || []).find(c => (c.powerValue || 1) === 1);
            power_card_to_add = themed_power_card || power_card_to_add;
        }
        if (power_card_to_add) deck.Power.push(power_card_to_add);
        else break;
    }
        
    return deck;
}

// --- DECK DISPLAY & EVENT LISTENERS ---

const populateList = (listElement, cards, displayFormatter) => {
    listElement.innerHTML = '';
    if (cards.length === 0) { listElement.innerHTML = '<li>None</li>'; return; }
    const counts = new Map();
    cards.forEach(card => {
        const key = displayFormatter(card);
        counts.set(key, (counts.get(key) || 0) + 1);
    });
    const uniqueKeys = [];
    const seen = new Set();
    cards.forEach(card => {
        const key = displayFormatter(card);
        if (!seen.has(key)) {
            uniqueKeys.push(key);
            seen.add(key);
        }
    });

    uniqueKeys.forEach(key => {
        const li = document.createElement('li');
        li.textContent = `${key} x${counts.get(key)}`;
        listElement.appendChild(li);
    });
};

function renderCreatureList(sortOrder = 'asc') {
    if (!currentDeck) return;
    const sortedCreatures = [...currentDeck.Creatures]; 
    
    if (sortOrder === 'asc') {
        sortedCreatures.sort((a, b) => (a.level || 0) - (b.level || 0) || a.name.localeCompare(b.name));
    } else { // desc
        sortedCreatures.sort((a, b) => (b.level || 0) - (a.level || 0) || a.name.localeCompare(b.name));
    }
    
    populateList(creaturesListUl, sortedCreatures, c => `${c.name} (Lvl ${c.level || '?'}, ${(c.types || ['?'])[0]}, ${c.rarity})`);
}

function displayDeck(deck, deckTheme, archetype) {
    outputDiv.style.display = 'block';
    const color = ARCHETYPE_COLORS[archetype] || 'var(--text-color)';
    deckTitleH2.textContent = `${deckTheme} ${archetype} Deck`;
    [deckTitleH2, creaturesTitleH3, powerTitleH3, secretsTitleH3].forEach(el => el.style.color = color);
    const total = deck.Creatures.length + deck.Power.length + deck.Secrets.length;
    deckStatsP.textContent = `Total Cards: ${total} | Creatures: ${deck.Creatures.length}, Power: ${deck.Power.length}, Secrets: ${deck.Secrets.length}`;
    
    // --- **FIXED** Create and add sorting controls for creatures ---
    let oldSortControls = document.getElementById('creature-sort-controls');
    if (oldSortControls) oldSortControls.remove(); // Remove old controls to prevent bugs

    const sortControlsDiv = document.createElement('div');
    sortControlsDiv.id = 'creature-sort-controls';
    sortControlsDiv.className = 'sort-controls';
    
    const sortAscBtn = document.createElement('button');
    sortAscBtn.textContent = 'Sort 1-10';
    sortAscBtn.className = 'sort-btn';
    sortAscBtn.onclick = () => renderCreatureList('asc');
    
    const sortDescBtn = document.createElement('button');
    sortDescBtn.textContent = 'Sort 10-1';
    sortDescBtn.className = 'sort-btn';
    sortDescBtn.onclick = () => renderCreatureList('desc');
    
    sortControlsDiv.appendChild(sortAscBtn);
    sortControlsDiv.appendChild(sortDescBtn);
    creaturesTitleH3.appendChild(sortControlsDiv);
    
    renderCreatureList('asc'); // Default sort
    populateList(powerListUl, deck.Power, p => `${p.powerType} Power ${(p.powerValue || 1) === 2 ? '(x2)' : ''} (${p.rarity})`);
    populateList(secretsListUl, deck.Secrets, s => `${s.name} (${(s.subtypes || ['?'])[0]}, ${s.rarity})`);
}

// --- JSON GENERATION FUNCTIONS ---

function generateDeckName() {
    const prefixes = ["Crimson", "Azure", "Verdant", "Shadow", "Gilded", "Ironclad", "Howling", "Silent", "Arcane", "Solar"];
    const suffixes = ["Fury", "Guard", "Storm", "Whisper", "Legacy", "Dawn", "Vengeance", "Heart", "Rage", "Dominion"];
    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
    return `${prefix} ${suffix}`;
}

function formatDeckAsJson(deck, deckTheme) {
    try {
        const allDeckCards = [...deck.Creatures, ...deck.Power, ...deck.Secrets];
        const cardCounts = new Map();
        for (const card of allDeckCards) {
            if (card.id === undefined) throw new Error(`Card "${card.name}" is missing a required 'id' field.`);
            const cardId = parseInt(card.id, 10);
            cardCounts.set(cardId, (cardCounts.get(cardId) || 0) + 1);
        }
        const formattedCards = Array.from(cardCounts.entries());
        const outputDeck = {
            id: String(randInt(2000, 9999)),
            name: generateDeckName(),
            types: deckTheme.split('/'),
            cards: formattedCards,
            setCode: "MC01"
        };
        const baseJsonString = JSON.stringify(outputDeck, null, 2);
        const indentedLines = baseJsonString.split('\n').map(line => '  ' + line);
        return indentedLines.join('\n') + ',';
    } catch (e) {
        console.error("Error formatting deck as JSON:", e);
        statusDiv.textContent = `Error: ${e.message} Cannot generate JSON.`;
        statusDiv.style.color = 'var(--color-red-status)';
        return null;
    }
}

async function initialize() {
    Object.entries(DECK_ARCHETYPES).forEach(([name, data], index) => {
        const input = document.createElement('input');
        input.type = 'radio'; input.id = `archetype-${name}`; input.name = 'archetype'; input.value = name;
        if (index === 0) input.checked = true;
        const label = document.createElement('label');
        label.htmlFor = `archetype-${name}`; label.textContent = name; label.title = data.description;
        archetypeOptionsDiv.appendChild(input);
        archetypeOptionsDiv.appendChild(label);
    });

    // --- Create and append JSON generator section with new structure ---
    const mainContainer = document.querySelector('.main-container');
    const jsonSection = document.createElement('div');
    jsonSection.id = 'json-generator-section';
    jsonSection.style.display = 'none';
    
    const jsonButton = document.createElement('button');
    jsonButton.id = 'generate-json-btn';
    jsonButton.className = 'action-button';
    jsonButton.textContent = 'Generate Deck JSON';
    
    const codeBlock = document.createElement('div');
    codeBlock.className = 'code-block-wrapper';
    codeBlock.style.display = 'none';
    
    const header = document.createElement('div');
    header.className = 'code-header';
    const title = document.createElement('span');
    title.textContent = 'Deck JSON Output';
    const copyBtn = document.createElement('button');
    copyBtn.id = 'copy-json-btn';
    copyBtn.textContent = 'Copy code';
    header.appendChild(title);
    header.appendChild(copyBtn);
    
    const body = document.createElement('div');
    body.className = 'code-body';
    const jsonPre = document.createElement('pre');
    jsonPre.id = 'json-output';
    body.appendChild(jsonPre);

    const warningDiv = document.createElement('div');
    warningDiv.id = 'json-warning';
    warningDiv.innerHTML = `⚠️ <strong>WARNING</strong> ⚠️ This JSON format is exclusively valid for the deckProfiles.json file and is intended solely for coding purposes. Do not use this format for other applications or files, as it may not be compatible with other systems or use cases.`;

    codeBlock.appendChild(header);
    codeBlock.appendChild(body);
    codeBlock.appendChild(warningDiv);
    
    jsonSection.appendChild(jsonButton);
    jsonSection.appendChild(codeBlock);
    mainContainer.appendChild(jsonSection);

    // --- Add event listeners ---
    jsonButton.addEventListener('click', () => {
        if (!currentDeck) {
            alert('Please generate a deck first before creating JSON.');
            return;
        }
        const jsonString = formatDeckAsJson(currentDeck, currentDeckTheme);
        if (jsonString) {
            jsonPre.textContent = jsonString;
            codeBlock.style.display = 'block';
            copyBtn.textContent = 'Copy code';
        }
    });

    copyBtn.addEventListener('click', () => {
        navigator.clipboard.writeText(jsonPre.textContent).then(() => {
            copyBtn.textContent = 'Copied!';
            setTimeout(() => { copyBtn.textContent = 'Copy code'; }, 2000);
        }, (err) => {
            console.error('Failed to copy text: ', err);
            alert('Failed to copy text.');
        });
    });

    const cardDataUrl = 'https://raw.githubusercontent.com/nerdrealm/mystik_builder/main/cardProfiles.json';
    all_cards = await loadCardsFromJson(cardDataUrl);
    if (all_cards) {
        companion_map = getCompanionMap(all_cards);
        statusDiv.textContent = `Ready to build. Please select a theme and archetype.`;
        statusDiv.style.color = 'var(--color-green-status)';
        generateBtn.disabled = false;
    } else {
        generateBtn.disabled = true;
    }

    generateBtn.addEventListener('click', () => {
        const rawThemeInput = themeInput.value.trim();
        if (!rawThemeInput) { alert("Please enter a Deck Type Theme."); return; }
        
        const deckTheme = rawThemeInput.replace(/[,\s]+/g, '/').split('/').map(p => p.trim()).filter(p => p).map(p => p.charAt(0).toUpperCase() + p.slice(1).toLowerCase()).join('/');
        const archetype = document.querySelector('input[name="archetype"]:checked').value;
        
        statusDiv.textContent = `Building a(n) ${archetype} deck with the ${deckTheme} theme...`;
        statusDiv.style.color = 'var(--color-cyan-status)';
        cautionDiv.style.display = 'none';
        
        jsonSection.style.display = 'none';
        codeBlock.style.display = 'none';
        
        setTimeout(() => {
            try {
                const deck = buildStrategicDeck(deckTheme, archetype);
                currentDeck = deck;
                currentDeckTheme = deckTheme;
                displayDeck(deck, deckTheme, archetype);
                statusDiv.textContent = "Deck generated successfully!";
                statusDiv.style.color = 'var(--color-green-status)';
                cautionDiv.style.display = 'block';
                jsonSection.style.display = 'flex';
            } catch (e) {
                statusDiv.textContent = "An error occurred during deck generation. See console for details.";
                statusDiv.style.color = 'var(--color-red-status)';
                console.error(e);
            }
        }, 50);
    });
}

initialize();

});
</script>

</body>
</html>
