<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystik Creatures Deck Builder</title>
    <style>
        :root {
            --bg-color: #1e1e1e; /* Charcoal Black */
            --container-bg: #2d2d2d; /* Slightly Lighter Charcoal */
            --input-bg: #3c3c3c;
            --text-color: #FFD700; /* Golden Yellow */
            --text-light: #dcdcdc;
            --border-color: #FFD700; /* Golden Yellow */
            --btn-color: #FFD700; /* Golden Yellow */
            --btn-text-color: #1e1e1e; /* Dark text on yellow button */
            --btn-hover-color: #ffeb99; /* Lighter yellow for hover */
            
            /* Status Colors */
            --color-yellow-status: #f1c40f;
            --color-red-status: #e74c3c;
            --color-green-status: #2ecc71;
            --color-cyan-status: #1abc9c;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .main-container {
            width: 100%;
            max-width: 1200px;
            background-color: var(--container-bg);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.25);
        }

        header {
            display: flex; 
            align-items: center; 
            justify-content: center; 
            margin-bottom: 25px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 20px;
        }

        header img {
            max-width: 200px; 
            margin-right: 25px; 
        }

        header h1 {
            color: var(--text-color);
            margin: 0;
            font-size: 2.5em; 
            text-shadow: 0 0 5px var(--text-color);
        }

        #status {
            text-align: center;
            padding: 10px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
            color: var(--color-yellow-status);
            border: 1px solid;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background-color: var(--bg-color);
            border-radius: 8px;
        }
        
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            margin-bottom: 5px; 
            font-weight: bold;
            color: var(--text-color);
        }

        .theme-hint {
            font-size: 0.85em;
            color: #bbbbbb;
            margin-top: 0;
            margin-bottom: 10px;
            font-style: italic;
        }

        .control-group input[type="text"] {
            padding: 12px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-light);
            font-size: 1em;
        }
        
        .archetype-options {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .archetype-options label {
            cursor: pointer;
            padding: 10px 15px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            transition: all 0.2s ease-in-out;
        }
        
        .archetype-options input[type="radio"] {
            display: none;
        }
        
        .archetype-options input[type="radio"]:checked + label {
            background-color: var(--btn-color);
            color: var(--btn-text-color);
            font-weight: bold;
            box-shadow: 0 0 10px var(--btn-color);
        }

        #archetype-Balanced:checked + label {
            background-color: var(--color-green-status);
            box-shadow: 0 0 10px var(--color-green-status);
            color: var(--btn-text-color);
            border-color: var(--color-green-status);
        }
        #archetype-Aggro:checked + label {
            background-color: var(--color-red-status);
            box-shadow: 0 0 10px var(--color-red-status);
            color: var(--text-light);
            border-color: var(--color-red-status);
        }
        #archetype-Control:checked + label {
            background-color: var(--color-yellow-status);
            box-shadow: 0 0 10px var(--color-yellow-status);
            color: var(--btn-text-color);
            border-color: var(--color-yellow-status);
        }
        #archetype-Energy:checked + label {
            background-color: var(--color-cyan-status);
            box-shadow: 0 0 10px var(--color-cyan-status);
            color: var(--btn-text-color);
            border-color: var(--color-cyan-status);
        }


        .action-button {
            grid-column: 1 / -1;
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            color: var(--btn-text-color);
            background-color: var(--btn-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .action-button:hover {
            background-color: var(--btn-hover-color);
        }
        
        .action-button:disabled {
            background-color: #555;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
            border-color: #555;
        }

        #output {
            display: none; 
            padding-bottom: 20px;
        }
        
        #caution-message {
            text-align: center;
            padding: 15px;
            background-color: var(--bg-color);
            border: 2px solid var(--color-yellow-status);
            border-radius: 8px;
            margin-bottom: 20px;
        }

        #caution-message h3 {
            margin: 0 0 10px 0;
            font-weight: bold;
            text-transform: uppercase;
            color: var(--color-yellow-status);
        }

        #caution-message p {
            margin: 0;
            line-height: 1.5;
            color: var(--text-light);
        }
        
        #caution-message p:first-of-type {
            margin-bottom: 10px;
        }

        #deck-summary {
            text-align: center;
            padding: 15px;
            background-color: var(--bg-color);
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        #deck-summary h2 {
            margin: 0 0 10px 0;
            color: var(--text-color);
        }
        
        #deck-list-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .card-list {
            background-color: var(--bg-color);
            padding: 15px;
            border-radius: 8px;
        }
        
        .card-list h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--border-color);
            color: var(--text-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        
        .card-list ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        
        .card-list li {
            padding: 5px 0;
            border-bottom: 1px solid var(--input-bg);
        }

        .card-list li:last-child {
            border-bottom: none;
        }

        .sort-controls {
            display: inline-flex;
            gap: 8px;
            margin-left: 15px;
            vertical-align: middle;
        }
        .sort-btn {
            background-color: var(--input-bg);
            color: var(--text-light);
            border: 1px solid var(--border-color);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            cursor: pointer;
        }
        .sort-btn:hover {
            background-color: var(--border-color);
            color: var(--btn-text-color);
        }

        #json-generator-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: center; 
            gap: 20px; 
        }
        
        .code-block-wrapper {
            width: 100%;
            max-width: 800px;
            border: 1px solid var(--input-bg);
            border-radius: 8px;
            background-color: #111;
            overflow: hidden; 
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--input-bg);
            padding: 8px 15px;
            color: var(--text-light);
            font-size: 0.9em;
        }

        #copy-json-btn {
            background: none;
            border: 1px solid #777;
            color: #ccc;
            padding: 4px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }
        #copy-json-btn:hover {
            background-color: #555;
            color: white;
            border-color: #999;
        }

        .code-body {
            padding: 15px;
        }

        #json-output {
            background: none;
            color: #dcdcdc;
            padding: 0;
            margin: 0;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            border: none;
        }
        
        #json-warning {
            padding: 12px 15px;
            background-color: rgba(241, 196, 15, 0.1); 
            border-top: 1px solid var(--color-yellow-status);
            color: #f3dca1;
            font-size: 0.9em;
            line-height: 1.4;
        }
        #json-warning strong {
            color: var(--color-yellow-status);
        }

    </style>
</head>
<body>

    <div class="main-container">
        <header>
            <img src="https://raw.githubusercontent.com/nerdrealm/mystik_builder/main/MystikLogo-PNG.png" 
                 alt="Mystik Creatures Logo" 
                 onerror="this.style.display='none'; this.nextSibling.style.display='block';">
            <p style="display:none; color: var(--color-red-status);">Logo failed to load. Make sure 'MystikLogo-PNG.png' exists in your public GitHub repository.</p>
            <h1>Mystik Creatures Deck Builder</h1>
        </header>

        <div id="status">Loading card data... Please wait.</div>

        <div class="controls">
            <div class="control-group">
                <label for="deckTheme">Deck Type Theme</label>
                <p class="theme-hint">Types: Fire, Water, Dark, Thunder, Earth, Wind, Forest, Light, or Blank. <br>Combine two or more with a slash, space, or comma.</p>
                <input type="text" id="deckTheme" placeholder="Enter a theme here...">
            </div>

            <div class="control-group">
                <label>Deck Archetype</label>
                <div id="archetype-options" class="archetype-options">
                    <!-- Options will be populated by JS -->
                </div>
            </div>

            <button id="generate-btn" class="action-button" disabled>Generate Deck</button>
        </div>

        <div id="caution-message" style="display: none;">
            <h3>CAUTION</h3>
            <p>Some cards in this deck may not fit your build or strategy, and others may not meet official deck-building rules.</p>
            <p>Always tailor your deck around your core Creatures, and be sure to follow all level, rarity, and card limits.</p>
        </div>

        <div id="output">
            <div id="deck-summary">
                <h2 id="deck-title"></h2>
                <p id="deck-stats"></p>
            </div>
            <div id="deck-list-container">
                <div class="card-list">
                    <h3 id="creatures-title">Creatures</h3>
                    <ul id="creatures-list"></ul>
                </div>
                <div class="card-list">
                    <h3 id="power-title">Power</h3>
                    <ul id="power-list"></ul>
                </div>
                <div class="card-list">
                    <h3 id="secrets-title">Secrets</h3>
                    <ul id="secrets-list"></ul>
                </div>
            </div>
        </div>
        <!-- JSON generator will be inserted here by JS -->
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

// --- CONFIGURATION & DECK RULES ---
const DECK_RULES = {
    "deck_size": 60,
    "creature_card_limits": { "Common": 4, "Uncommon": 3, "Rare": 2, "UltraRare": 2 },
    "level_10_limits": { "total": 4 },
    "power_card_limits": { "powerValue_1": Infinity, "powerValue_2": 5 },
    "secret_card_limits": { "Common": 3, "Uncommon": 2, "Rare": 1 }
};

const DECK_ARCHETYPES = {
    "Balanced": { "creatures": 0.40, "secrets": 0.35, "power": 0.25, "description": "A well-rounded deck" },
    "Aggro": { "creatures": 0.50, "secrets": 0.25, "power": 0.25, "description": "Creature-heavy and aggressive" },
    "Control": { "creatures": 0.30, "secrets": 0.45, "power": 0.25, "description": "Secret-heavy and disruptive" },
    "Energy": { "creatures": 0.35, "secrets": 0.30, "power": 0.35, "description": "Power-heavy for big plays" }
};

const ARCHETYPE_COLORS = {
    "Balanced": "var(--color-green-status)",
    "Aggro": "var(--color-red-status)",
    "Control": "var(--color-yellow-status)",
    "Energy": "var(--color-cyan-status)"
};

const TERRAIN_TYPE_COMPATIBILITY = {
    "Ancient Forests of Rehm": ["Forest"], "Aquatic Paradise": ["Water", "Forest"], "Dark Shadows": ["Dark"],
    "Huricanes off Jimbora": ["Thunder"], "Infernal Pits of Crom": ["Fire"], "Lights of Nura": ["Light"],
    "Mountains of Eurotha": ["Earth"], "Oceans of Nimbitu": ["Water"], "Pixie Forest": ["Forest"],
    "Poisonous Swamp": ["Earth", "Dark"], "Rough Seas": ["Water"], "Sacred Grounds": ["Thunder", "Light"],
    "Sandstorm": ["Earth"], "Scorched Fields": ["Wind", "Fire"], "Shadow Plains": ["Dark"],
    "Southern Winds of Us'ah": ["Wind"], "Star of Septeptus": ["Light"], "Stomy Skies": ["Thunder"],
    "Torn Wastelands": ["All"], "Volcanoes of Westu'ra": ["Fire"], "Winds off the Coast": ["Wind"]
};

const BOSS_COMPANION_MAP = {
    "Arcana Temptress": ["Arcana Apprentice"],
    "Dracoleón": ["Nemean Lion"],
    "Hydra": ["Nereus"],
    "Infinity Mage": ["Infinity Apprentice"],
    "Phoenix, the Rising": ["Phoenic"],
    "Serpopard": ["Anuket"],
    "Werelephant": ["Pebblephant", "Moonlight Awakening"],
    "Zombified Dragon": ["Dragon Tamer"],
    "Divine Beast Panterus": ["Winged Beast U'ru", "Winged Beast Wai'ku", "Winged Beast Ra'zu"],
    "Astraea": [],
    "Aurora, the Paladin": [],
    "Avani": [],
    "Bristleback": [],
    "Cloudpiercer": [],
    "Eamonn": [],
    "Ephemeral Empress": [],
    "Hikaru, Thunderflame": [],
    "Ignimia": ["Flames of Bahtu"],
    "Iškugriff": ["Storm of Reckoning"],
    "Isxóhe": ["Spirit Guide"],
    "Kaia": [],
    "Kuroen": [],
    "Laviathron": [],
    "Lilith, Forest Pixie": ["Lilith's Garden"],
    "Malum, the Damned": ["Ritual of the Damned"],
    "Raitei": [],
    "Rann, the Wretched": ["Abandoned Ship"],
    "Strix Arenaeus": [],
    "Tempestas": [],
    "Tetsu Yami": [],
    "Wilderfang": [],
    "Wolfdrake": []
};

const BANNED_SECRET_CARDS = [
    "Aquatic Conversion", "Celestial Storm", "Corrupt Evolution", "Divine Transformation",
    "Elemental Infusion", "Infernal Transmutation", "Mystik Forestry", "Primeval Mutation",
    "Windy Metamorphosis", "Elemental Break"
];


// --- GLOBAL VARIABLES & DOM ELEMENTS ---
let all_cards = [];
let companion_map = {};
let currentDeck = null;
let currentDeckTheme = '';

const statusDiv = document.getElementById('status');
const generateBtn = document.getElementById('generate-btn');
const themeInput = document.getElementById('deckTheme');
const archetypeOptionsDiv = document.getElementById('archetype-options');
const outputDiv = document.getElementById('output');
const deckTitleH2 = document.getElementById('deck-title');
const deckStatsP = document.getElementById('deck-stats');
const creaturesListUl = document.getElementById('creatures-list');
const powerListUl = document.getElementById('power-list');
const secretsListUl = document.getElementById('secrets-list');
const creaturesTitleH3 = document.getElementById('creatures-title');
const powerTitleH3 = document.getElementById('power-title');
const secretsTitleH3 = document.getElementById('secrets-title');
const cautionDiv = document.getElementById('caution-message');

const defaultdict = (defaultValueFactory) => new Proxy({}, {
    get: (target, name) => name in target ? target[name] : (target[name] = defaultValueFactory())
});

// --- UTILITY FUNCTIONS ---
const shuffle = (array) => {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
};

// --- DATA LOADING & INITIALIZATION ---
async function loadCardsFromJson(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        const unique_cards = [];
        const seen = new Set();
        for (const card of data) {
            if (!card.id) {
                console.warn(`Card "${card.name}" is missing an 'id' field, which is required for JSON export.`);
            }
            card.script_uuid = crypto.randomUUID();
            const identifier = `${card.name}|${card.collectionNumber}`;
            if (!seen.has(identifier)) {
                unique_cards.push(card);
                seen.add(identifier);
            }
        }
        return unique_cards;
    } catch (e) {
        statusDiv.innerHTML = `<strong>ERROR:</strong> Failed to fetch card data.`;
        statusDiv.style.color = 'var(--color-red-status)';
        console.error("Error loading card data:", e);
        return null;
    }
}

// --- SYNERGY & HELPER FUNCTIONS ---
function getCompanionMap(cards) {
    const newCompanionMap = defaultdict(() => ({ creatures: [], secrets: [] }));
    for (const card of cards) {
        if (card.supertype !== 'Creature') continue;
        for (const ability of card.abilities || []) {
            for (const prereq of ability.prerequisites || []) {
                if (prereq.type === 'SacrificeSpecificCreature') newCompanionMap[card.name].creatures.push(prereq.creatureName);
                else if (prereq.type === 'PlaySpecificCard') newCompanionMap[card.name].secrets.push(prereq.cardName);
                else if (prereq.type === 'HasCreatureInPlay') newCompanionMap[card.name].creatures.push(prereq.creatureName);
            }
        }
    }
    return newCompanionMap;
}

function analyzePowerRequirements(creatures) {
    const powerNeeds = defaultdict(() => 0);
    for (const creature of creatures) {
        for (const attack of creature.attacks || []) {
            for (const cost of attack.cost || []) {
                powerNeeds[cost.PowerType] += cost.count;
            }
        }
    }
    return powerNeeds;
}

function scoreCreatureSynergy(card, deckTheme) {
    let score = Math.random() * 20;
    const cardTypes = card.types || [];
    const themeTypes = deckTheme.split('/');
    if (!themeTypes.some(t => cardTypes.includes(t))) return -1;
    score += 50;
    if (themeTypes.length > 1 && themeTypes.every(t => cardTypes.includes(t))) score += 40;
    if (Object.values(companion_map).some(v => v.creatures.includes(card.name))) score += 30; // Is a companion
    if (card.name in companion_map) score += 30; // Is a boss
    if (card.rarity === 'Rare') score += 15;
    if (card.rarity === 'UltraRare') score += 25;
    if ((card.level || 0) >= 7) score += 10;
    return score;
}

function scoreSecretSynergy(card, deckTheme, creaturesInDeck) {
    const cardName = card.name || '';
    if (BANNED_SECRET_CARDS.includes(cardName)) return -1;
    for (const bossName in companion_map) {
        if ((companion_map[bossName].secrets || []).includes(cardName)) {
            return creaturesInDeck.some(c => c.name === bossName) ? 1000 : -1;
        }
    }
    let score = Math.random() * 10;
    const themeTypes = deckTheme.split('/');
    if ((card.subtypes || [null])[0] === 'Terrain') {
        if (deckTheme === 'Blank') return -1;
        const validTypes = TERRAIN_TYPE_COMPATIBILITY[cardName] || [];
        if (validTypes.includes("All") || themeTypes.some(theme => validTypes.includes(theme))) {
            score += 80;
        } else {
            return -1;
        }
    } else {
        const effectText = (card.effectText || '').toLowerCase();
        for (const theme of themeTypes) {
            if (effectText.includes(theme.toLowerCase())) score += 25;
        }
    }
    return score;
}

/**
 * Decides how many Level 10 bosses to add using a weighted random distribution.
 * This makes the deck building feel more natural and less predictable.
 * @returns {number} The number of bosses to attempt to add (0-4).
 */
function getWeightedRandomBossCount() {
    const weights = {
        0: 10,  // 10% chance for a 'no-boss' deck
        1: 30,  // 30% chance for a single-boss focus
        2: 40,  // 40% chance for a standard two-boss deck (most common)
        3: 15,  // 15% chance for a powerful three-boss deck
        4: 5    // 5% chance for a rare "max-boss" deck
    };
    const totalWeight = Object.values(weights).reduce((sum, weight) => sum + weight, 0);
    let random = Math.random() * totalWeight;

    for (const [count, weight] of Object.entries(weights)) {
        random -= weight;
        if (random <= 0) {
            return parseInt(count, 10);
        }
    }
    return 2; // Fallback, should not be reached
}

function buildStrategicDeck(selectedTypes, archetype_name) {
    const deck = { "Creatures": [], "Power": [], "Secrets": [] };
    const archetype = DECK_ARCHETYPES[archetype_name];
    const is_blank_deck = (selectedTypes === 'Blank');

    let targetCreatures = Math.floor(DECK_RULES.deck_size * archetype.creatures);
    let targetSecrets = Math.floor(DECK_RULES.deck_size * archetype.secrets);
    let targetPower = DECK_RULES.deck_size - targetCreatures - targetSecrets;
    
    const all_creatures = all_cards.filter(c => c.supertype === 'Creature');
    const creatureCounts = defaultdict(() => 0);
    let level_10_count = 0;

    // --- STEP 1: SELECT "BOSS" CREATURES USING WEIGHTED RANDOMNESS ---
    const themeTypes = selectedTypes.split('/');
    let potential_bosses = all_creatures.filter(c => 
        c.level === 10 && 
        c.rarity === 'UltraRare' &&
        (is_blank_deck || (c.types || []).some(t => themeTypes.includes(t)))
    );
    
    const num_bosses_to_add = getWeightedRandomBossCount();
    let bosses_added_this_run = [];
    let attempts = 0;

    // This loop adds the desired number of bosses, respecting the "2 of each" rule.
    while (level_10_count < num_bosses_to_add && potential_bosses.length > 0 && attempts < 50) {
        const chosen_boss = potential_bosses[Math.floor(Math.random() * potential_bosses.length)];
        
        if (creatureCounts[chosen_boss.name] < DECK_RULES.creature_card_limits.UltraRare && level_10_count < DECK_RULES.level_10_limits.total) {
            deck.Creatures.push(chosen_boss);
            creatureCounts[chosen_boss.name]++;
            level_10_count++;
            // Keep track of the unique bosses added to fetch companions later
            if (!bosses_added_this_run.find(b => b.name === chosen_boss.name)) {
                bosses_added_this_run.push(chosen_boss);
            }
        }
        attempts++; // Failsafe to prevent infinite loops
    }
    
    // --- STEP 2: ADD COMPANIONS FOR THE CHOSEN BOSSES ---
    for (const boss of bosses_added_this_run) {
         if (boss.name in BOSS_COMPANION_MAP) {
            for (const comp_name of BOSS_COMPANION_MAP[boss.name]) {
                if (deck.Creatures.length >= targetCreatures) break;
                const comp_card = all_creatures.find(c => c.name === comp_name);
                if (comp_card) {
                    const { rarity: cc_rarity } = comp_card;
                    if (creatureCounts[comp_name] < (DECK_RULES.creature_card_limits[cc_rarity] || 1)) {
                        deck.Creatures.push(comp_card);
                        creatureCounts[comp_name]++;
                    }
                }
            }
        }
    }

    // --- STEP 3: FILL REMAINING SLOTS WITH OTHER SYNERGISTIC CREATURES ---
    const added_creature_uuids = new Set(deck.Creatures.map(c => c.script_uuid));
    
    let remaining_creatures = all_creatures.filter(c => 
        !added_creature_uuids.has(c.script_uuid) && // Exclude already added cards
        (is_blank_deck || (c.types || []).some(t => themeTypes.includes(t)))
    );

    let creature_pool = remaining_creatures.map(c => [c, scoreCreatureSynergy(c, selectedTypes)])
        .filter(([c, s]) => s >= 0)
        .sort((a,b) => b[1] - a[1]);

    while (deck.Creatures.length < targetCreatures && creature_pool.length > 0) {
        const candidatePoolSize = Math.min(10, creature_pool.length);
        if (candidatePoolSize === 0) break;
        const randomIndex = Math.floor(Math.random() * candidatePoolSize);
        const [card_to_add, _] = creature_pool.splice(randomIndex, 1)[0]; 

        const { name: card_name, rarity: card_rarity, level: card_level = 0 } = card_to_add;

        if ((card_level === 10 && level_10_count >= DECK_RULES.level_10_limits.total) || (creatureCounts[card_name] >= (DECK_RULES.creature_card_limits[card_rarity] || 1))) {
            continue; 
        }

        deck.Creatures.push(card_to_add);
        creatureCounts[card_name]++;
        if (card_level === 10) level_10_count++;
    }
    
    // --- STEP 4: POWER CARD SELECTION ---
    const power_needs = analyzePowerRequirements(deck.Creatures);
    let power_tasks = [];
    for (const type in power_needs) {
        for (let i = 0; i < power_needs[type]; i++) {
            power_tasks.push(type);
        }
    }
    const allCreatureTypesInDeck = [...new Set(deck.Creatures.flatMap(c => c.types || []))];
    allCreatureTypesInDeck.forEach(type => {
        if (!power_needs[type]) { 
            for(let i = 0; i < 2; i++) power_tasks.push(type);
        }
    });
    shuffle(power_tasks);

    const powerCardsByType = defaultdict(() => []);
    all_cards.filter(c => c.supertype === 'Power').forEach(c => powerCardsByType[c.powerType].push(c));

    let double_power_count = 0;
    while (deck.Power.length < targetPower) {
        if (power_tasks.length === 0) {
            let fill_type = is_blank_deck ? 'Blank' : selectedTypes.split('/')[0];
            const card = powerCardsByType[fill_type].find(c => (c.powerValue || 1) === 1) || powerCardsByType['Blank'].find(c => (c.powerValue || 1) === 1);
            if (card) deck.Power.push(card); else break;
            continue;
        }

        const next_power_type = power_tasks.shift();
        
        const use_double = (double_power_count < DECK_RULES.power_card_limits.powerValue_2 && 
                            power_tasks.filter(t => t === next_power_type).length > 0 && 
                            powerCardsByType[next_power_type].some(c => (c.powerValue || 1) === 2));

        if (use_double) {
            const card_to_add = powerCardsByType[next_power_type].find(c => (c.powerValue || 1) === 2);
            deck.Power.push(card_to_add);
            double_power_count++;
            const second_task_index = power_tasks.findIndex(t => t === next_power_type);
            if(second_task_index > -1) power_tasks.splice(second_task_index, 1);
        } else {
            const card_to_add = powerCardsByType[next_power_type].find(c => (c.powerValue || 1) === 1) || powerCardsByType['Blank'].find(c => (c.powerValue || 1) === 1);
            if(card_to_add) deck.Power.push(card_to_add);
        }
    }

    // --- STEP 5: SECRET CARD SELECTION ---
    const available_secrets = all_cards.filter(c => c.supertype === 'Secret');
    let scored_secrets = available_secrets
        .map(secret => [secret, scoreSecretSynergy(secret, selectedTypes, deck.Creatures)])
        .filter(([_, score]) => score >= 0)
        .sort((a, b) => b[1] - a[1]);

    const secret_counts = defaultdict(() => 0);
    while (deck.Secrets.length < targetSecrets && scored_secrets.length > 0) {
        const [card_to_add, _] = scored_secrets.shift();
        const { name: card_name, rarity: card_rarity, subtypes: card_subtypes = [] } = card_to_add;
        const current_terrain_count = deck.Secrets.filter(c => (c.subtypes || []).includes('Terrain')).length;
        const terrain_names = new Set(deck.Secrets.filter(c => (c.subtypes || []).includes('Terrain')).map(c => c.name));

        if (secret_counts[card_name] >= (DECK_RULES.secret_card_limits[card_rarity] || 1)) continue;
        if (card_subtypes.includes('Terrain') && (current_terrain_count >= 4 || (!terrain_names.has(card_name) && terrain_names.size >= 3))) continue;
        
        deck.Secrets.push(card_to_add);
        secret_counts[card_name]++;
    }
        
    // --- STEP 6: FINAL DECK SIZE ADJUSTMENT ---
    while (deck.Creatures.length + deck.Power.length + deck.Secrets.length < DECK_RULES.deck_size) {
         const card = powerCardsByType['Blank'].find(c => (c.powerValue || 1) === 1);
         if(card) deck.Power.push(card); else break;
    }
     while (deck.Creatures.length + deck.Power.length + deck.Secrets.length > DECK_RULES.deck_size) {
        if(deck.Power.length > targetPower) deck.Power.pop();
        else if (deck.Secrets.length > targetSecrets) deck.Secrets.pop();
        else if (deck.Creatures.length > targetCreatures) deck.Creatures.pop();
        else { 
            deck.Power.length > 0 ? deck.Power.pop() : deck.Secrets.pop();
        }
    }
        
    return deck;
}

const populateList = (listElement, cards, displayFormatter) => {
    listElement.innerHTML = '';
    if (cards.length === 0) { listElement.innerHTML = '<li>None</li>'; return; }
    const counts = new Map();
    cards.forEach(card => {
        const key = displayFormatter(card);
        counts.set(key, (counts.get(key) || 0) + 1);
    });
    const uniqueKeys = [];
    const seen = new Set();
    cards.forEach(card => {
        const key = displayFormatter(card);
        if (!seen.has(key)) {
            uniqueKeys.push(key);
            seen.add(key);
        }
    });

    uniqueKeys.forEach(key => {
        const li = document.createElement('li');
        li.textContent = `${key} x${counts.get(key)}`;
        listElement.appendChild(li);
    });
};

function renderCreatureList(sortOrder = 'asc') {
    if (!currentDeck) return;
    const sortedCreatures = [...currentDeck.Creatures]; 
    
    if (sortOrder === 'asc') {
        sortedCreatures.sort((a, b) => (a.level || 0) - (b.level || 0) || a.name.localeCompare(b.name));
    } else { // desc
        sortedCreatures.sort((a, b) => (b.level || 0) - (a.level || 0) || a.name.localeCompare(b.name));
    }
    
    populateList(creaturesListUl, sortedCreatures, c => `${c.name} (Lvl ${c.level || '?'}, ${(c.types || ['?'])[0]}, ${c.rarity})`);
}

function displayDeck(deck, deckTheme, archetype) {
    outputDiv.style.display = 'block';
    const color = ARCHETYPE_COLORS[archetype] || 'var(--text-color)';
    deckTitleH2.textContent = `${deckTheme} ${archetype} Deck`;
    [deckTitleH2, creaturesTitleH3, powerTitleH3, secretsTitleH3].forEach(el => el.style.color = color);
    const total = deck.Creatures.length + deck.Power.length + deck.Secrets.length;
    deckStatsP.textContent = `Total Cards: ${total} | Creatures: ${deck.Creatures.length}, Power: ${deck.Power.length}, Secrets: ${deck.Secrets.length}`;
    
    let oldSortControls = document.getElementById('creature-sort-controls');
    if (oldSortControls) oldSortControls.remove();

    const sortControlsDiv = document.createElement('div');
    sortControlsDiv.id = 'creature-sort-controls';
    sortControlsDiv.className = 'sort-controls';
    
    const sortAscBtn = document.createElement('button');
    sortAscBtn.textContent = 'Sort 1-10';
    sortAscBtn.className = 'sort-btn';
    sortAscBtn.onclick = () => renderCreatureList('asc');
    
    const sortDescBtn = document.createElement('button');
    sortDescBtn.textContent = 'Sort 10-1';
    sortDescBtn.className = 'sort-btn';
    sortDescBtn.onclick = () => renderCreatureList('desc');
    
    sortControlsDiv.appendChild(sortAscBtn);
    sortControlsDiv.appendChild(sortDescBtn);
    creaturesTitleH3.appendChild(sortControlsDiv);
    
    renderCreatureList('asc');
    populateList(powerListUl, deck.Power, p => `${p.powerType} Power ${(p.powerValue || 1) === 2 ? '(x2)' : ''} (${p.rarity})`);
    populateList(secretsListUl, deck.Secrets, s => `${s.name} (${(s.subtypes || ['?'])[0]}, ${s.rarity})`);
}

function generateDeckName() {
    const prefixes = ["Crimson", "Azure", "Verdant", "Shadow", "Gilded", "Ironclad", "Howling", "Silent", "Arcane", "Solar"];
    const suffixes = ["Fury", "Guard", "Storm", "Whisper", "Legacy", "Dawn", "Vengeance", "Heart", "Rage", "Dominion"];
    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
    return `${prefix} ${suffix}`;
}

function formatDeckAsJson(deck, deckTheme) {
    try {
        const allDeckCards = [...deck.Creatures, ...deck.Power, ...deck.Secrets];
        const cardCounts = new Map();
        for (const card of allDeckCards) {
            if (card.id === undefined) throw new Error(`Card "${card.name}" is missing a required 'id' field.`);
            const cardId = parseInt(card.id, 10);
            cardCounts.set(cardId, (cardCounts.get(cardId) || 0) + 1);
        }
        const formattedCards = Array.from(cardCounts.entries());
        const outputDeck = {
            id: String(Math.floor(Math.random() * (9999 - 2000 + 1) + 2000)),
            name: generateDeckName(),
            types: deckTheme.split('/'),
            cards: formattedCards,
            setCode: "MC01"
        };
        const baseJsonString = JSON.stringify(outputDeck, null, 2);
        const indentedLines = baseJsonString.split('\n').map(line => '  ' + line);
        return indentedLines.join('\n') + ',';
    } catch (e) {
        console.error("Error formatting deck as JSON:", e);
        statusDiv.textContent = `Error: ${e.message} Cannot generate JSON.`;
        statusDiv.style.color = 'var(--color-red-status)';
        return null;
    }
}

async function initialize() {
    Object.entries(DECK_ARCHETYPES).forEach(([name, data], index) => {
        const input = document.createElement('input');
        input.type = 'radio'; input.id = `archetype-${name}`; input.name = 'archetype'; input.value = name;
        if (index === 0) input.checked = true;
        const label = document.createElement('label');
        label.htmlFor = `archetype-${name}`; label.textContent = name; label.title = data.description;
        archetypeOptionsDiv.appendChild(input);
        archetypeOptionsDiv.appendChild(label);
    });

    const mainContainer = document.querySelector('.main-container');
    const jsonSection = document.createElement('div');
    jsonSection.id = 'json-generator-section';
    jsonSection.style.display = 'none';
    
    const jsonButton = document.createElement('button');
    jsonButton.id = 'generate-json-btn';
    jsonButton.className = 'action-button';
    jsonButton.textContent = 'Generate Deck JSON';
    
    const codeBlock = document.createElement('div');
    codeBlock.className = 'code-block-wrapper';
    codeBlock.style.display = 'none';
    
    const header = document.createElement('div');
    header.className = 'code-header';
    const title = document.createElement('span');
    title.textContent = 'Deck JSON Output';
    const copyBtn = document.createElement('button');
    copyBtn.id = 'copy-json-btn';
    copyBtn.textContent = 'Copy code';
    header.appendChild(title);
    header.appendChild(copyBtn);
    
    const body = document.createElement('div');
    body.className = 'code-body';
    const jsonPre = document.createElement('pre');
    jsonPre.id = 'json-output';
    body.appendChild(jsonPre);

    const warningDiv = document.createElement('div');
    warningDiv.id = 'json-warning';
    warningDiv.innerHTML = `⚠️ <strong>WARNING</strong> ⚠️ This JSON format is exclusively valid for the deckProfiles.json file and is intended solely for coding purposes. Do not use this format for other applications or files, as it may not be compatible with other systems or use cases.`;

    codeBlock.appendChild(header);
    codeBlock.appendChild(body);
    codeBlock.appendChild(warningDiv);
    
    jsonSection.appendChild(jsonButton);
    jsonSection.appendChild(codeBlock);
    mainContainer.appendChild(jsonSection);

    jsonButton.addEventListener('click', () => {
        if (!currentDeck) {
            alert('Please generate a deck first before creating JSON.');
            return;
        }
        const jsonString = formatDeckAsJson(currentDeck, currentDeckTheme);
        if (jsonString) {
            jsonPre.textContent = jsonString;
            codeBlock.style.display = 'block';
            copyBtn.textContent = 'Copy code';
        }
    });

    copyBtn.addEventListener('click', () => {
        navigator.clipboard.writeText(jsonPre.textContent).then(() => {
            copyBtn.textContent = 'Copied!';
            setTimeout(() => { copyBtn.textContent = 'Copy code'; }, 2000);
        }, (err) => {
            console.error('Failed to copy text: ', err);
            alert('Failed to copy text.');
        });
    });

    const cardDataUrl = 'https://raw.githubusercontent.com/nerdrealm/mystik_builder/main/cardProfiles.json';
    all_cards = await loadCardsFromJson(cardDataUrl);
    if (all_cards) {
        companion_map = getCompanionMap(all_cards);
        statusDiv.textContent = `Ready to build. Please select a theme and archetype.`;
        statusDiv.style.color = 'var(--color-green-status)';
        generateBtn.disabled = false;
    } else {
        generateBtn.disabled = true;
    }

    generateBtn.addEventListener('click', () => {
        const rawThemeInput = themeInput.value.trim();
        if (!rawThemeInput) { alert("Please enter a Deck Type Theme."); return; }
        
        const deckTheme = rawThemeInput.replace(/[,\s]+/g, '/').split('/').map(p => p.trim()).filter(p => p).map(p => p.charAt(0).toUpperCase() + p.slice(1).toLowerCase()).join('/');
        const archetype = document.querySelector('input[name="archetype"]:checked').value;
        
        statusDiv.textContent = `Building a(n) ${archetype} deck with the ${deckTheme} theme...`;
        statusDiv.style.color = 'var(--color-cyan-status)';
        cautionDiv.style.display = 'none';
        
        jsonSection.style.display = 'none';
        codeBlock.style.display = 'none';
        
        setTimeout(() => {
            try {
                const deck = buildStrategicDeck(deckTheme, archetype);
                currentDeck = deck;
                currentDeckTheme = deckTheme;
                displayDeck(deck, deckTheme, archetype);
                statusDiv.textContent = "Deck generated successfully!";
                statusDiv.style.color = 'var(--color-green-status)';
                cautionDiv.style.display = 'block';
                jsonSection.style.display = 'flex';
            } catch (e) {
                statusDiv.textContent = "An error occurred during deck generation. See console for details.";
                statusDiv.style.color = 'var(--color-red-status)';
                console.error(e);
            }
        }, 50);
    });

    themeInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !generateBtn.disabled) {
            event.preventDefault(); 
            generateBtn.click();    
        }
    });
}

initialize();

});
</script>

</body>
</html>
