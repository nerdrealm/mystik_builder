<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystik Creatures Deck Builder</title>
    <style>
        :root {
            --bg-color: #1e1e1e; /* Charcoal Black */
            --container-bg: #2d2d2d; /* Slightly Lighter Charcoal */
            --input-bg: #3c3c3c;
            --text-color: #FFD700; /* Golden Yellow */
            --text-light: #dcdcdc;
            --border-color: #FFD700; /* Golden Yellow */
            --btn-color: #FFD700; /* Golden Yellow */
            --btn-text-color: #1e1e1e; /* Dark text on yellow button */
            --btn-hover-color: #ffeb99; /* Lighter yellow for hover */
            
            /* Status Colors */
            --color-yellow-status: #f1c40f;
            --color-red-status: #e74c3c;
            --color-green-status: #2ecc71;
            --color-cyan-status: #1abc9c;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .main-container {
            width: 100%;
            max-width: 1200px;
            background-color: var(--container-bg);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.25);
        }

        header {
            display: flex; 
            align-items: center; 
            justify-content: center; 
            margin-bottom: 25px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 20px;
        }

        header img {
            max-width: 200px; 
            margin-right: 25px; 
        }

        header h1 {
            color: var(--text-color);
            margin: 0;
            font-size: 2.5em; 
            text-shadow: 0 0 5px var(--text-color);
        }

        #status {
            text-align: center;
            padding: 10px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
            color: var(--color-yellow-status);
            border: 1px solid;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background-color: var(--bg-color);
            border-radius: 8px;
        }
        
        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            margin-bottom: 5px; 
            font-weight: bold;
            color: var(--text-color);
        }

        .theme-hint {
            font-size: 0.85em;
            color: #bbbbbb;
            margin-top: 0;
            margin-bottom: 10px;
            font-style: italic;
        }

        .control-group input[type="text"] {
            padding: 12px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-light);
            font-size: 1em;
        }
        
        .archetype-options {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .archetype-options label {
            cursor: pointer;
            padding: 10px 15px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            transition: all 0.2s ease-in-out;
        }
        
        .archetype-options input[type="radio"] {
            display: none;
        }
        
        .archetype-options input[type="radio"]:checked + label {
            background-color: var(--btn-color);
            color: var(--btn-text-color);
            font-weight: bold;
            box-shadow: 0 0 10px var(--btn-color);
        }

        .action-button {
            grid-column: 1 / -1;
            padding: 15px;
            font-size: 1.2em;
            font-weight: bold;
            color: var(--btn-text-color);
            background-color: var(--btn-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .action-button:hover {
            background-color: var(--btn-hover-color);
        }
        
        .action-button:disabled {
            background-color: #555;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
            border-color: #555;
        }

        #output {
            display: none; 
            padding-bottom: 20px;
        }
        
        #caution-message {
            text-align: center;
            padding: 15px;
            background-color: var(--bg-color);
            border: 2px solid var(--color-yellow-status);
            border-radius: 8px;
            margin-bottom: 20px;
        }

        #caution-message h3 {
            margin: 0 0 10px 0;
            font-weight: bold;
            text-transform: uppercase;
            color: var(--color-yellow-status);
        }

        #caution-message p {
            margin: 0;
            line-height: 1.5;
            color: var(--text-light);
        }
        
        #caution-message p:first-of-type {
            margin-bottom: 10px;
        }

        #deck-summary {
            text-align: center;
            padding: 15px;
            background-color: var(--bg-color);
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        #deck-summary h2 {
            margin: 0 0 10px 0;
            color: var(--text-color);
        }
        
        #deck-list-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .card-list {
            background-color: var(--bg-color);
            padding: 15px;
            border-radius: 8px;
        }
        
        .card-list h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--border-color);
            color: var(--text-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        
        .card-list ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        
        .card-list li {
            padding: 5px 0;
            border-bottom: 1px solid var(--input-bg);
        }

        .card-list li:last-child {
            border-bottom: none;
        }

        /* Styles for dynamic Creature sort buttons */
        .sort-controls {
            display: inline-flex;
            gap: 8px;
            margin-left: 15px;
            vertical-align: middle;
        }
        .sort-btn {
            background-color: var(--input-bg);
            color: var(--text-light);
            border: 1px solid var(--border-color);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            cursor: pointer;
        }
        .sort-btn:hover {
            background-color: var(--border-color);
            color: var(--btn-text-color);
        }

        /* Styles for new JSON Generator Section */
        #json-generator-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: center; /* Center the button */
            gap: 20px; /* Space between button and code block */
        }
        
        /* New AI-style code block */
        .code-block-wrapper {
            width: 100%;
            max-width: 800px;
            border: 1px solid var(--input-bg);
            border-radius: 8px;
            background-color: #111;
            overflow: hidden; /* Ensures children conform to border-radius */
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--input-bg);
            padding: 8px 15px;
            color: var(--text-light);
            font-size: 0.9em;
        }

        #copy-json-btn {
            background: none;
            border: 1px solid #777;
            color: #ccc;
            padding: 4px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }
        #copy-json-btn:hover {
            background-color: #555;
            color: white;
            border-color: #999;
        }

        .code-body {
            padding: 15px;
        }

        #json-output {
            background: none;
            color: #dcdcdc;
            padding: 0;
            margin: 0;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            border: none;
        }
        
        #json-warning {
            padding: 12px 15px;
            background-color: rgba(241, 196, 15, 0.1); /* Yellow transparent bg */
            border-top: 1px solid var(--color-yellow-status);
            color: #f3dca1;
            font-size: 0.9em;
            line-height: 1.4;
        }
        #json-warning strong {
            color: var(--color-yellow-status);
        }

    </style>
</head>
<body>

    <div class="main-container">
        <header>
            <img src="https://raw.githubusercontent.com/nerdrealm/mystik_builder/main/MystikLogo-PNG.png" 
                 alt="Mystik Creatures Logo" 
                 onerror="this.style.display='none'; this.nextSibling.style.display='block';">
            <p style="display:none; color: var(--color-red-status);">Logo failed to load. Make sure 'MystikLogo-PNG.png' exists in your public GitHub repository.</p>
            <h1>Mystik Creatures Deck Builder</h1>
        </header>

        <div id="status">Loading card data... Please wait.</div>

        <div class="controls">
            <div class="control-group">
                <label for="deckTheme">Deck Type Theme</label>
                <p class="theme-hint">Types: Fire, Water, Dark, Thunder, Earth, Wind, Forest, Light, or Blank. <br>Combine two or more with a slash, space, or comma.</p>
                <input type="text" id="deckTheme" placeholder="Enter a theme here...">
            </div>

            <div class="control-group">
                <label>Deck Archetype</label>
                <div id="archetype-options" class="archetype-options">
                    <!-- Options will be populated by JS -->
                </div>
            </div>

            <button id="generate-btn" class="action-button" disabled>Generate Deck</button>
        </div>

        <div id="caution-message" style="display: none;">
            <h3>CAUTION</h3>
            <p>Some cards in this deck may not fit your build or strategy, and others may not meet official deck-building rules.</p>
            <p>Always tailor your deck around your core Creatures, and be sure to follow all level, rarity, and card limits.</p>
        </div>

        <div id="output">
            <div id="deck-summary">
                <h2 id="deck-title"></h2>
                <p id="deck-stats"></p>
            </div>
            <div id="deck-list-container">
                <div class="card-list">
                    <h3 id="creatures-title">Creatures</h3>
                    <ul id="creatures-list"></ul>
                </div>
                <div class="card-list">
                    <h3 id="power-title">Power</h3>
                    <ul id="power-list"></ul>
                </div>
                <div class="card-list">
                    <h3 id="secrets-title">Secrets</h3>
                    <ul id="secrets-list"></ul>
                </div>
            </div>
        </div>
        <!-- JSON generator will be inserted here by JS -->
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

// --- CONFIGURATION & DECK RULES ---
const DECK_RULES = {
    "deck_size": 60,
    "creature_card_limits": { "Common": 4, "Uncommon": 3, "Rare": 2, "UltraRare": 2 },
    "level_10_limits": { "total": 4 },
    "power_card_limits": { "powerValue_1": Infinity, "powerValue_2": 5 },
    "secret_card_limits": { "Common": 3, "Uncommon": 2, "Rare": 1 }
};

const DECK_ARCHETYPES = {
    "Balanced": { "creatures": 0.40, "secrets": 0.35, "power": 0.25, "description": "A well-rounded deck" },
    "Aggro": { "creatures": 0.50, "secrets": 0.25, "power": 0.25, "description": "Creature-heavy and aggressive" },
    "Control": { "creatures": 0.30, "secrets": 0.45, "power": 0.25, "description": "Secret-heavy and disruptive" },
    "Energy": { "creatures": 0.35, "secrets": 0.30, "power": 0.35, "description": "Power-heavy for big plays" }
};

const ARCHETYPE_COLORS = {
    "Balanced": "var(--color-green-status)",
    "Aggro": "var(--color-red-status)",
    "Control": "var(--color-yellow-status)",
    "Energy": "var(--color-cyan-status)"
};

const TERRAIN_TYPE_COMPATIBILITY = {
    "Ancient Forests of Rehm": ["Forest"], "Aquatic Paradise": ["Water", "Forest"], "Dark Shadows": ["Dark"],
    "Huricanes off Jimbora": ["Thunder"], "Infernal Pits of Crom": ["Fire"], "Lights of Nura": ["Light"],
    "Mountains of Eurotha": ["Earth"], "Oceans of Nimbitu": ["Water"], "Pixie Forest": ["Forest"],
    "Poisonous Swamp": ["Earth", "Dark"], "Rough Seas": ["Water"], "Sacred Grounds": ["Thunder", "Light"],
    "Sandstorm": ["Earth"], "Scorched Fields": ["Wind", "Fire"], "Shadow Plains": ["Dark"],
    "Southern Winds of Us'ah": ["Wind"], "Star of Septeptus": ["Light"], "Stomy Skies": ["Thunder"],
    "Torn Wastelands": ["All"], "Volcanoes of Westu'ra": ["Fire"], "Winds off the Coast": ["Wind"]
};

const BOSS_COMPANION_MAP = {
    "Arcana Temptress": ["Arcana Apprentice"],
    "Dracoleón": ["Nemean Lion"],
    "Hydra": ["Nereus"],
    "Infinity Mage": ["Infinity Apprentice"],
    "Phoenix, the Rising": ["Phoenic"],
    "Serpopard": ["Anuket"],
    "Werelephant": ["Pebblephant"],
    "Zombified Dragon": ["Dragon Tamer"],
    "Divine Beast Panterus": ["Winged Beast U'ru", "Winged Beast Wai'ku", "Winged Beast Ra'zu"]
};

const BANNED_SECRET_CARDS = [
    "Aquatic Conversion", "Celestial Storm", "Corrupt Evolution", "Divine Transformation",
    "Elemental Infusion", "Infernal Transmutation", "Mystik Forestry", "Primeval Mutation",
    "Windy Metamorphosis", "Elemental Break"
];


// --- GLOBAL VARIABLES & DOM ELEMENTS ---
let all_cards = [];
let companion_map = {};
let currentDeck = null;
let currentDeckTheme = '';

const statusDiv = document.getElementById('status');
const generateBtn = document.getElementById('generate-btn');
const themeInput = document.getElementById('deckTheme');
const archetypeOptionsDiv = document.getElementById('archetype-options');
const outputDiv = document.getElementById('output');
const deckTitleH2 = document.getElementById('deck-title');
const deckStatsP = document.getElementById('deck-stats');
const creaturesListUl = document.getElementById('creatures-list');
const powerListUl = document.getElementById('power-list');
const secretsListUl = document.getElementById('secrets-list');
const creaturesTitleH3 = document.getElementById('creatures-title');
const powerTitleH3 = document.getElementById('power-title');
const secretsTitleH3 = document.getElementById('secrets-title');
const cautionDiv = document.getElementById('caution-message');

const defaultdict = (defaultValueFactory) => new Proxy({}, {
    get: (target, name) => name in target ? target[name] : (target[name] = defaultValueFactory())
});

// --- UTILITY FUNCTIONS ---
const shuffle = (array) => {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
};

// --- DATA LOADING & INITIALIZATION ---
async function loadCardsFromJson(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        const unique_cards = [];
        const seen = new Set();
        for (const card of data) {
            if (!card.id) {
                console.warn(`Card "${card.name}" is missing an 'id' field, which is required for JSON export.`);
            }
            card.script_uuid = crypto.randomUUID();
            const identifier = `${card.name}|${card.collectionNumber}`;
            if (!seen.has(identifier)) {
                unique_cards.push(card);
                seen.add(identifier);
            }
        }
        return unique_cards;
    } catch (e) {
        statusDiv.innerHTML = `<strong>ERROR:</strong> Failed to fetch card data.`;
        statusDiv.style.color = 'var(--color-red-status)';
        console.error("Error loading card data:", e);
        return null;
    }
}

// --- SYNERGY & HELPER FUNCTIONS ---
function getCompanionMap(cards) {
    const newCompanionMap = defaultdict(() => ({ creatures: [], secrets: [] }));
    for (const card of cards) {
        if (card.supertype !== 'Creature') continue;
        for (const ability of card.abilities || []) {
            for (const prereq of ability.prerequisites || []) {
                if (prereq.type === 'SacrificeSpecificCreature') newCompanionMap[card.name].creatures.push(prereq.creatureName);
                else if (prereq.type === 'PlaySpecificCard') newCompanionMap[card.name].secrets.push(prereq.cardName);
                else if (prereq.type === 'HasCreatureInPlay') newCompanionMap[card.name].creatures.push(prereq.creatureName);
            }
        }
    }
    return newCompanionMap;
}

function analyzePowerRequirements(creatures) {
    const powerNeeds = defaultdict(() => 0);
    for (const creature of creatures) {
        for (const attack of creature.attacks || []) {
            for (const cost of attack.cost || []) {
                powerNeeds[cost.PowerType] += cost.count;
            }
        }
    }
    return powerNeeds;
}

function scoreCreatureSynergy(card, deckTheme) {
    let score = Math.random() * 20; // Use float for more granularity
    const cardTypes = card.types || [];
    const themeTypes = deckTheme.split('/');
    if (!themeTypes.some(t => cardTypes.includes(t))) return -1;
    score += 50;
    if (themeTypes.length > 1 && themeTypes.every(t => cardTypes.includes(t))) score += 40;
    if (Object.values(companion_map).some(v => v.creatures.includes(card.name))) score += 30;
    if (card.name in companion_map) score += 30;
    if (card.rarity === 'Rare') score += 15;
    if (card.rarity === 'UltraRare') score += 25;
    if ((card.level || 0) >= 7) score += 10;
    return score;
}

function scoreSecretSynergy(card, deckTheme, creaturesInDeck) {
    const cardName = card.name || '';
    if (BANNED_SECRET_CARDS.includes(cardName)) return -1;
    for (const bossName in companion_map) {
        if ((companion_map[bossName].secrets || []).includes(cardName)) {
            return creaturesInDeck.some(c => c.name === bossName) ? 1000 : -1;
        }
    }
    let score = Math.random() * 10;
    const themeTypes = deckTheme.split('/');
    if ((card.subtypes || [null])[0] === 'Terrain') {
        if (deckTheme === 'Blank') return -1;
        const validTypes = TERRAIN_TYPE_COMPATIBILITY[cardName] || [];
        if (validTypes.includes("All") || themeTypes.some(theme => validTypes.includes(theme))) {
            score += 80;
        } else {
            return -1;
        }
    } else {
        const effectText = (card.effectText || '').toLowerCase();
        for (const theme of themeTypes) {
            if (effectText.includes(theme.toLowerCase())) score += 25;
        }
    }
    return score;
}

function buildStrategicDeck(selectedTypes, archetype_name) {
    const deck = { "Creatures": [], "Power": [], "Secrets": [] };
    const archetype = DECK_ARCHETYPES[archetype_name];
    const is_blank_deck = (selectedTypes === 'Blank');

    let targetCreatures = Math.floor(DECK_RULES.deck_size * archetype.creatures);
    let targetSecrets = Math.floor(DECK_RULES.deck_size * archetype.secrets);
    let targetPower = DECK_RULES.deck_size - targetCreatures - targetSecrets; // Ensure it adds up to 60
    
    const all_creatures = all_cards.filter(c => c.supertype === 'Creature');
    const creatureSelectionFn = is_blank_deck ? scoreCreatureSynergy : (c) => scoreCreatureSynergy(c, selectedTypes);
    
    // --- **FIX #2**: Aggressive Shuffling for Creature Variety ---
    let available_creatures = shuffle(all_creatures.filter(c => is_blank_deck || (c.types || []).some(t => selectedTypes.split('/').includes(t))));
    
    const creature_pool = available_creatures.map(c => [c, creatureSelectionFn(c)]).filter(([c, s]) => s >= 0).sort((a,b) => b[1] - a[1]);
    
    const creatureCounts = defaultdict(() => 0);
    let level_10_count = 0;

    // --- STEP 1: FINALIZE CREATURE LIST ---
    while (deck.Creatures.length < targetCreatures && creature_pool.length > 0) {
        const [card_to_add, _] = creature_pool.shift(); // Take the current best
        const { name: card_name, rarity: card_rarity, level: card_level = 0 } = card_to_add;

        if ((card_level === 10 && level_10_count >= DECK_RULES.level_10_limits.total) || (creatureCounts[card_name] >= (DECK_RULES.creature_card_limits[card_rarity] || 1))) {
            continue; // Skip if limit is reached
        }

        deck.Creatures.push(card_to_add);
        creatureCounts[card_name]++;
        if (card_level === 10) level_10_count++;
        
        if (card_name in BOSS_COMPANION_MAP) {
            for (const comp_name of BOSS_COMPANION_MAP[card_name]) {
                if (deck.Creatures.length >= targetCreatures) break;
                const comp_card = all_creatures.find(c => c.name === comp_name);
                if (comp_card) {
                    const { rarity: cc_rarity, level: cc_level = 0 } = comp_card;
                    if (creatureCounts[comp_name] < (DECK_RULES.creature_card_limits[cc_rarity] || 1) && !(cc_level === 10 && level_10_count >= DECK_RULES.level_10_limits.total)) {
                        deck.Creatures.push(comp_card);
                        creatureCounts[comp_name]++;
                        if (cc_level === 10) level_10_count++;
                    }
                }
            }
        }
    }

    // --- **FIX #3**: Power Card Logic Overhaul ---
    const power_needs = analyzePowerRequirements(deck.Creatures);
    let power_tasks = [];
    for (const type in power_needs) {
        for (let i = 0; i < power_needs[type]; i++) {
            power_tasks.push(type);
        }
    }

    // Add a minimum base for any type present in the deck, even if they have no attack costs
    const allCreatureTypesInDeck = [...new Set(deck.Creatures.flatMap(c => c.types || []))];
    allCreatureTypesInDeck.forEach(type => {
        if (!power_needs[type]) { // If a type has 0 attack costs, it still needs some power
            for(let i = 0; i < 2; i++) power_tasks.push(type);
        }
    });

    shuffle(power_tasks);

    const powerCardsByType = defaultdict(() => []);
    all_cards.filter(c => c.supertype === 'Power').forEach(c => powerCardsByType[c.powerType].push(c));

    let double_power_count = 0;
    while (deck.Power.length < targetPower) {
        if (power_tasks.length === 0) { // If no specific needs left, fill with Blank or main theme
            let fill_type = is_blank_deck ? 'Blank' : selectedTypes.split('/')[0];
            const card = powerCardsByType[fill_type].find(c => (c.powerValue || 1) === 1) || powerCardsByType['Blank'].find(c => (c.powerValue || 1) === 1);
            if (card) deck.Power.push(card); else break;
            continue;
        }

        const next_power_type = power_tasks.shift();
        
        // Prioritize double power cards to fulfill needs faster
        const use_double = (double_power_count < DECK_RULES.power_card_limits.powerValue_2 && 
                            power_tasks.filter(t => t === next_power_type).length > 0 && // Check if there's at least one more task of this type
                            powerCardsByType[next_power_type].some(c => (c.powerValue || 1) === 2));

        if (use_double) {
            const card_to_add = powerCardsByType[next_power_type].find(c => (c.powerValue || 1) === 2);
            deck.Power.push(card_to_add);
            double_power_count++;
            // Remove a second task of the same type
            const second_task_index = power_tasks.findIndex(t => t === next_power_type);
            if(second_task_index > -1) power_tasks.splice(second_task_index, 1);
        } else {
            const card_to_add = powerCardsByType[next_power_type].find(c => (c.powerValue || 1) === 1) || powerCardsByType['Blank'].find(c => (c.powerValue || 1) === 1);
            if(card_to_add) deck.Power.push(card_to_add);
        }
    }

    // --- STEP 4: SECRET CARD SELECTION ---
    const available_secrets = all_cards.filter(c => c.supertype === 'Secret');
    let scored_secrets = [];
    for (const secret of available_secrets) {
        const synergy_score = scoreSecretSynergy(secret, selectedTypes, deck.Creatures);
        if (synergy_score >= 0) scored_secrets.push([secret, synergy_score]);
    }
    scored_secrets.sort((a, b) => b[1] - a[1]);

    const secret_counts = defaultdict(() => 0);
    while (deck.Secrets.length < targetSecrets && scored_secrets.length > 0) {
        const [card_to_add, _] = scored_secrets.shift();
        const { name: card_name, rarity: card_rarity, subtypes: card_subtypes = [] } = card_to_add;
        const current_terrain_count = deck.Secrets.filter(c => (c.subtypes || []).includes('Terrain')).length;
        const terrain_names = new Set(deck.Secrets.filter(c => (c.subtypes || []).includes('Terrain')).map(c => c.name));

        if (secret_counts[card_name] >= (DECK_RULES.secret_card_limits[card_rarity] || 1)) continue;
        if (card_subtypes.includes('Terrain') && (current_terrain_count >= 4 || (!terrain_names.has(card_name) && terrain_names.size >= 3))) continue;
        
        deck.Secrets.push(card_to_add);
        secret_counts[card_name]++;
    }
        
    // --- STEP 5: FINAL ADJUSTMENT ---
    while (deck.Creatures.length + deck.Power.length + deck.Secrets.length < 60) {
         const card = powerCardsByType['Blank'].find(c => (c.powerValue || 1) === 1);
         if(card) deck.Power.push(card); else break;
    }
     while (deck.Creatures.length + deck.Power.length + deck.Secrets.length > 60) {
        if(deck.Power.length > targetPower) deck.Power.pop();
        else if (deck.Secrets.length > targetSecrets) deck.Secrets.pop();
        else deck.Creatures.pop();
    }
        
    return deck;
}


// --- DECK DISPLAY & EVENT LISTENERS ---

const populateList = (listElement, cards, displayFormatter) => {
    listElement.innerHTML = '';
    if (cards.length === 0) { listElement.innerHTML = '<li>None</li>'; return; }
    const counts = new Map();
    cards.forEach(card => {
        const key = displayFormatter(card);
        counts.set(key, (counts.get(key) || 0) + 1);
    });
    const uniqueKeys = [];
    const seen = new Set();
    cards.forEach(card => {
        const key = displayFormatter(card);
        if (!seen.has(key)) {
            uniqueKeys.push(key);
            seen.add(key);
        }
    });

    uniqueKeys.forEach(key => {
        const li = document.createElement('li');
        li.textContent = `${key} x${counts.get(key)}`;
        listElement.appendChild(li);
    });
};

function renderCreatureList(sortOrder = 'asc') {
    if (!currentDeck) return;
    const sortedCreatures = [...currentDeck.Creatures]; 
    
    if (sortOrder === 'asc') {
        sortedCreatures.sort((a, b) => (a.level || 0) - (b.level || 0) || a.name.localeCompare(b.name));
    } else { // desc
        sortedCreatures.sort((a, b) => (b.level || 0) - (a.level || 0) || a.name.localeCompare(b.name));
    }
    
    populateList(creaturesListUl, sortedCreatures, c => `${c.name} (Lvl ${c.level || '?'}, ${(c.types || ['?'])[0]}, ${c.rarity})`);
}

function displayDeck(deck, deckTheme, archetype) {
    outputDiv.style.display = 'block';
    const color = ARCHETYPE_COLORS[archetype] || 'var(--text-color)';
    deckTitleH2.textContent = `${deckTheme} ${archetype} Deck`;
    [deckTitleH2, creaturesTitleH3, powerTitleH3, secretsTitleH3].forEach(el => el.style.color = color);
    const total = deck.Creatures.length + deck.Power.length + deck.Secrets.length;
    deckStatsP.textContent = `Total Cards: ${total} | Creatures: ${deck.Creatures.length}, Power: ${deck.Power.length}, Secrets: ${deck.Secrets.length}`;
    
    let oldSortControls = document.getElementById('creature-sort-controls');
    if (oldSortControls) oldSortControls.remove();

    const sortControlsDiv = document.createElement('div');
    sortControlsDiv.id = 'creature-sort-controls';
    sortControlsDiv.className = 'sort-controls';
    
    const sortAscBtn = document.createElement('button');
    sortAscBtn.textContent = 'Sort 1-10';
    sortAscBtn.className = 'sort-btn';
    sortAscBtn.onclick = () => renderCreatureList('asc');
    
    const sortDescBtn = document.createElement('button');
    sortDescBtn.textContent = 'Sort 10-1';
    sortDescBtn.className = 'sort-btn';
    sortDescBtn.onclick = () => renderCreatureList('desc');
    
    sortControlsDiv.appendChild(sortAscBtn);
    sortControlsDiv.appendChild(sortDescBtn);
    creaturesTitleH3.appendChild(sortControlsDiv);
    
    renderCreatureList('asc');
    populateList(powerListUl, deck.Power, p => `${p.powerType} Power ${(p.powerValue || 1) === 2 ? '(x2)' : ''} (${p.rarity})`);
    populateList(secretsListUl, deck.Secrets, s => `${s.name} (${(s.subtypes || ['?'])[0]}, ${s.rarity})`);
}

// --- JSON GENERATION FUNCTIONS ---

function generateDeckName() {
    const prefixes = ["Crimson", "Azure", "Verdant", "Shadow", "Gilded", "Ironclad", "Howling", "Silent", "Arcane", "Solar"];
    const suffixes = ["Fury", "Guard", "Storm", "Whisper", "Legacy", "Dawn", "Vengeance", "Heart", "Rage", "Dominion"];
    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
    return `${prefix} ${suffix}`;
}

function formatDeckAsJson(deck, deckTheme) {
    try {
        const allDeckCards = [...deck.Creatures, ...deck.Power, ...deck.Secrets];
        const cardCounts = new Map();
        for (const card of allDeckCards) {
            if (card.id === undefined) throw new Error(`Card "${card.name}" is missing a required 'id' field.`);
            const cardId = parseInt(card.id, 10);
            cardCounts.set(cardId, (cardCounts.get(cardId) || 0) + 1);
        }
        const formattedCards = Array.from(cardCounts.entries());
        const outputDeck = {
            id: String(Math.floor(Math.random() * (9999 - 2000 + 1) + 2000)),
            name: generateDeckName(),
            types: deckTheme.split('/'),
            cards: formattedCards,
            setCode: "MC01"
        };
        const baseJsonString = JSON.stringify(outputDeck, null, 2);
        const indentedLines = baseJsonString.split('\n').map(line => '  ' + line);
        return indentedLines.join('\n') + ',';
    } catch (e) {
        console.error("Error formatting deck as JSON:", e);
        statusDiv.textContent = `Error: ${e.message} Cannot generate JSON.`;
        statusDiv.style.color = 'var(--color-red-status)';
        return null;
    }
}

async function initialize() {
    Object.entries(DECK_ARCHETYPES).forEach(([name, data], index) => {
        const input = document.createElement('input');
        input.type = 'radio'; input.id = `archetype-${name}`; input.name = 'archetype'; input.value = name;
        if (index === 0) input.checked = true;
        const label = document.createElement('label');
        label.htmlFor = `archetype-${name}`; label.textContent = name; label.title = data.description;
        archetypeOptionsDiv.appendChild(input);
        archetypeOptionsDiv.appendChild(label);
    });

    const mainContainer = document.querySelector('.main-container');
    const jsonSection = document.createElement('div');
    jsonSection.id = 'json-generator-section';
    jsonSection.style.display = 'none';
    
    const jsonButton = document.createElement('button');
    jsonButton.id = 'generate-json-btn';
    jsonButton.className = 'action-button';
    jsonButton.textContent = 'Generate Deck JSON';
    
    const codeBlock = document.createElement('div');
    codeBlock.className = 'code-block-wrapper';
    codeBlock.style.display = 'none';
    
    const header = document.createElement('div');
    header.className = 'code-header';
    const title = document.createElement('span');
    title.textContent = 'Deck JSON Output';
    const copyBtn = document.createElement('button');
    copyBtn.id = 'copy-json-btn';
    copyBtn.textContent = 'Copy code';
    header.appendChild(title);
    header.appendChild(copyBtn);
    
    const body = document.createElement('div');
    body.className = 'code-body';
    const jsonPre = document.createElement('pre');
    jsonPre.id = 'json-output';
    body.appendChild(jsonPre);

    const warningDiv = document.createElement('div');
    warningDiv.id = 'json-warning';
    warningDiv.innerHTML = `⚠️ <strong>WARNING</strong> ⚠️ This JSON format is exclusively valid for the deckProfiles.json file and is intended solely for coding purposes. Do not use this format for other applications or files, as it may not be compatible with other systems or use cases.`;

    codeBlock.appendChild(header);
    codeBlock.appendChild(body);
    codeBlock.appendChild(warningDiv);
    
    jsonSection.appendChild(jsonButton);
    jsonSection.appendChild(codeBlock);
    mainContainer.appendChild(jsonSection);

    jsonButton.addEventListener('click', () => {
        if (!currentDeck) {
            alert('Please generate a deck first before creating JSON.');
            return;
        }
        const jsonString = formatDeckAsJson(currentDeck, currentDeckTheme);
        if (jsonString) {
            jsonPre.textContent = jsonString;
            codeBlock.style.display = 'block';
            copyBtn.textContent = 'Copy code';
        }
    });

    copyBtn.addEventListener('click', () => {
        navigator.clipboard.writeText(jsonPre.textContent).then(() => {
            copyBtn.textContent = 'Copied!';
            setTimeout(() => { copyBtn.textContent = 'Copy code'; }, 2000);
        }, (err) => {
            console.error('Failed to copy text: ', err);
            alert('Failed to copy text.');
        });
    });

    const cardDataUrl = 'https://raw.githubusercontent.com/nerdrealm/mystik_builder/main/cardProfiles.json';
    all_cards = await loadCardsFromJson(cardDataUrl);
    if (all_cards) {
        companion_map = getCompanionMap(all_cards);
        statusDiv.textContent = `Ready to build. Please select a theme and archetype.`;
        statusDiv.style.color = 'var(--color-green-status)';
        generateBtn.disabled = false;
    } else {
        generateBtn.disabled = true;
    }

    generateBtn.addEventListener('click', () => {
        const rawThemeInput = themeInput.value.trim();
        if (!rawThemeInput) { alert("Please enter a Deck Type Theme."); return; }
        
        const deckTheme = rawThemeInput.replace(/[,\s]+/g, '/').split('/').map(p => p.trim()).filter(p => p).map(p => p.charAt(0).toUpperCase() + p.slice(1).toLowerCase()).join('/');
        const archetype = document.querySelector('input[name="archetype"]:checked').value;
        
        statusDiv.textContent = `Building a(n) ${archetype} deck with the ${deckTheme} theme...`;
        statusDiv.style.color = 'var(--color-cyan-status)';
        cautionDiv.style.display = 'none';
        
        jsonSection.style.display = 'none';
        codeBlock.style.display = 'none';
        
        setTimeout(() => {
            try {
                const deck = buildStrategicDeck(deckTheme, archetype);
                currentDeck = deck;
                currentDeckTheme = deckTheme;
                displayDeck(deck, deckTheme, archetype);
                statusDiv.textContent = "Deck generated successfully!";
                statusDiv.style.color = 'var(--color-green-status)';
                cautionDiv.style.display = 'block';
                jsonSection.style.display = 'flex';
            } catch (e) {
                statusDiv.textContent = "An error occurred during deck generation. See console for details.";
                statusDiv.style.color = 'var(--color-red-status)';
                console.error(e);
            }
        }, 50);
    });
}

initialize();

});
</script>

</body>
</html>
